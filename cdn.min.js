document.addEventListener('DOMContentLoaded', () => {
    // Referencje do elementów DOM
    const boilerTempDisplay = document.getElementById('boilerTemp');
    const blowerPowerDisplay = document.getElementById('blowerPower');
    const flameStatusDisplay = document.getElementById('flameStatus');
    const deltaTempDisplay = document.getElementById('deltaTemp');
    const blowerRPMDisplay = document.getElementById('blowerRPM');
    const currentModeDisplay = document.getElementById('currentMode');
    const igniterPowerDisplay = document.getElementById('igniterPower');
    const burnerHoursTotalDisplay = document.getElementById('burnerHoursTotal');
    const exhaustTempDisplay = document.getElementById('exhaustTemp');
    const wifiRSSIDisplay = document.getElementById('wifiRSSI');
    const operatingTimeDisplay = document.getElementById('operatingTime');
    const reconnectCountDisplay = document.getElementById('reconnectCount');

    const targetTempSlider = document.getElementById('targetTempSlider');
    const targetTempDisplay = document.getElementById('targetTempDisplay');
    const fanPowerSlider = document.getElementById('fanPowerSlider');
    const fanPowerDisplay = document.getElementById('fanPowerDisplay');
    const feederSpeedSlider = document.getElementById('feederSpeedSlider');
    const feederSpeedDisplay = document.getElementById('feederSpeedDisplay');

    const igniteButton = document.getElementById('igniteButton');
    const stopBurnerButton = document.getElementById('stopBurnerButton');

    const modeOffButton = document.getElementById('modeOff');
    const modeManualButton = document.getElementById('modeManual');
    const modeAutoButton = document.getElementById('modeAuto');

    const flameIndicator = document.getElementById('flame-indicator');
    const igniterIndicator = document.getElementById('igniter-indicator');
    const ignitionStatusText = document.getElementById('ignition-status-text');
    const ignitionCountdown = document.getElementById('ignition-countdown');
    const ignitionTimerContainer = document.getElementById('ignition-timer');
    const ignitionProgressBar = document.getElementById('ignition-progress');
    const ignitionProgressCircle = document.getElementById('ignition-progress-circle');
    const ignitionProgressText = document.getElementById('ignition-progress-text');
    const currentIgnitionTemp = document.getElementById('current-ignition-temp');

    const cleanIntervalHoursInput = document.getElementById('cleanIntervalHours');
    const cleanDurationMinutesInput = document.getElementById('cleanDurationMinutes');
    const cleanBlowerPowerInput = document.getElementById('cleanBlowerPower');
    const updateCleanBtn = document.getElementById('updateCleanBtn');
    const autoCleanToggle = document.getElementById('autoCleanToggle');
    const maintenanceModeToggle = document.getElementById('maintenanceModeToggle');
    const maintenanceModeIndicator = document.getElementById('maintenanceModeIndicator');

    const maintenanceFeedOnTimeSlider = document.getElementById('maintenanceFeedOnTime');
    const maintenanceFeedOnTimeDisplay = document.getElementById('maintenanceFeedOnTimeDisplay');
    const maintenanceFeedOffTimeSlider = document.getElementById('maintenanceFeedOffTime');
    const maintenanceFeedOffTimeDisplay = document.getElementById('maintenanceFeedOffTimeDisplay');
    const blowerMaintenanceManualPowerSlider = document.getElementById('blowerMaintenanceManualPower');
    const blowerMaintenanceManualPowerDisplay = document.getElementById('blowerMaintenanceManualPowerDisplay');

    const blowerManualControlToggle = document.getElementById('blowerManualControlToggle');
    const blowerControlModeInfo = document.getElementById('blowerControlModeInfo');
    const blowerControlModeText = document.getElementById('blowerControlModeText');
    const blowerManualControlModeOff = document.getElementById('blowerManualControlModeOff');
    const blowerManualControlModeDirect = document.getElementById('blowerManualControlModeDirect');
    const blowerManualControlModeInverter = document.getElementById('blowerManualControlModeInverter');

    const blowerWorkPowerSlider = document.getElementById('blowerWorkPowerSlider');
    const blowerWorkPowerDisplay = document.getElementById('blowerWorkPowerDisplay');

    const tempCorrectionDisplay = document.getElementById('tempCorrectionDisplay');
    const tempCorrectionInput = document.getElementById('tempCorrectionInput');
    const setTempCorrectionBtn = document.getElementById('setTempCorrectionBtn');

    const resetStatisticsButton = document.getElementById('resetStatisticsButton');
    const resetAllDataButton = document.getElementById('resetAllDataButton');

    const mqttBrokerInput = document.getElementById('mqttBroker');
    const mqttPortInput = document.getElementById('mqttPort');
    const mqttUserInput = document.getElementById('mqttUser');
    const mqttPasswordInput = document.getElementById('mqttPassword');
    const mqttTopicStateInput = document.getElementById('mqttTopicState');
    const mqttTopicControlInput = document.getElementById('mqttTopicControl');
    const mqttConnectBtn = document.getElementById('mqttConnectBtn');
    const mqttDisconnectBtn = document.getElementById('mqttDisconnectBtn');
    const mqttStatusIndicator = document.getElementById('mqttStatusIndicator');
    const mqttStatusText = document.getElementById('mqttStatusText');

    const wifiStatusBadge = document.getElementById('wifiStatusBadge');
    const wifiStatusText = document.getElementById('wifiStatusText');
    const mqttStatusBadge = document.getElementById('mqttStatusBadge');
    const mqttStatusTextDiagram = document.getElementById('mqttStatusTextDiagram');
    const espStatusBadge = document.getElementById('espStatusBadge');
    const espStatusText = document.getElementById('espStatusText');

    const boilerSensorStatus = document.getElementById('boilerSensorStatus');
    const exhaustSensorStatus = document.getElementById('exhaustSensorStatus');
    const igniterStatus = document.getElementById('igniterStatus');
    const blowerStatusDevice = document.getElementById('blowerStatusDevice');
    const feederStatus = document.getElementById('feederStatus');

    const feederCycleStatus = document.getElementById('feederCycleStatus');
    const feederCycleProgressBar = document.getElementById('feederCycleProgressBar');
    const feederCycleInfo = document.getElementById('feederCycleInfo');

    const blowerPurgeStatus = document.getElementById('blowerPurgeStatus');
    const blowerPurgeProgressBar = document.getElementById('blowerPurgeProgressBar');
    const blowerPurgeInfo = document.getElementById('blowerPurgeInfo');
    const blowerPurgeOnTimeInput = document.getElementById('blowerPurgeOnTime');
    const blowerPurgeOffTimeInput = document.getElementById('blowerPurgeOffTime');
    const blowerPurgeManualPowerSlider = document.getElementById('blowerPurgeManualPower');
    const blowerPurgeManualPowerDisplay = document.getElementById('blowerPurgeManualPowerDisplay');
    const blowerPurgeModeInfo = document.getElementById('blowerPurgeModeInfo');
    const blowerPurgeModeText = document.getElementById('blowerPurgeModeText');
    const blowerPurgeModeOffBtn = document.getElementById('blowerPurgeModeOff');
    const blowerPurgeModeDirectBtn = document.getElementById('blowerPurgeModeDirect');
    const blowerPurgeModeInverterBtn = document.getElementById('blowerPurgeModeInverter');

    const ignitionTimeInput = document.getElementById('ignitionTime');
    const stabilizationTimeInput = document.getElementById('stabilizationTime');

    // History & Stats
    const historyBurnerTime = document.getElementById('historyBurnerTime');
    const historyPelletConsumption = document.getElementById('historyPelletConsumption');
    const historyAvgBlowerPower = document.getElementById('historyAvgBlowerPower');
    const historyAvgBoilerTemp = document.getElementById('historyAvgBoilerTemp');
    const pelletPriceInput = document.getElementById('pelletPriceInput');
    const estimatedConsumptionDisplay = document.getElementById('estimatedConsumption');
    const estimatedCostDisplay = document.getElementById('estimatedCostDisplay');
    const totalCalculatedCost = document.getElementById('totalCalculatedCost');
    const efficiencyGaugeFill = document.getElementById('efficiencyGaugeFill');
    const efficiencyGaugeLabel = document.getElementById('efficiencyGaugeLabel');

    // Chart elements
    let myChart;
    const chartLog = document.getElementById('chartLog');
    const chartTypeSwitcher = document.querySelector('.chart-switcher');
    const datasetToggles = document.querySelectorAll('.dataset-toggle');
    const historyRangeBtns = document.querySelectorAll('.history-btn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const resetZoomBtn = document.getElementById('resetZoomBtn');

    // MQTT Client instance
    let client;
    let mqttConnected = false;

    // State variables (frontend cache)
    let currentState = {};
    let chartData = {
        boilerTemp: [],
        exhaustTemp: [],
        targetTemp: [],
        timestamp: []
    };
    let activeChartDatasetIds = ['boilerTemp', 'exhaustTemp', 'targetTemp'];
    let currentChartMode = 'live'; // 'live', 'day', 'week', 'month'
    let currentHistoryRange = 'day'; // 'day', 'week', 'month'

    const TOPIC_PREFIX = "pellet/boiler/"; // Używany jako prefiks do state_topic i control_topic, jeśli nie są pełne.
    let fullStateTopic = "pellet/boiler/state";
    let fullControlTopic = "pellet/boiler/control";

    // --- Utility Functions ---
    function formatTime(seconds) {
        if (isNaN(seconds) || seconds < 0) return "--:--";
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    function updateFlameIndicator(isOn) {
        if (flameIndicator) {
            if (isOn) {
                flameIndicator.classList.remove('off');
                flameIndicator.classList.add('on');
            } else {
                flameIndicator.classList.remove('on');
                flameIndicator.classList.add('off');
            }
        }
    }

    function updateIgnitionStatus(status, progressPercent = 0, currentTemp = null, totalDuration = null, remainingTime = null) {
        if (!ignitionStatusText) return;

        ignitionStatusText.classList.remove('off', 'heating', 'ready', 'on');
        if (igniterIndicator) igniterIndicator.style.display = 'none'; // Ukryj domyślnie

        switch (status) {
            case 'OFF':
                ignitionStatusText.textContent = 'Wyłączony';
                ignitionStatusText.classList.add('off');
                ignitionTimerContainer.style.display = 'none';
                ignitionProgressBar.style.display = 'none';
                break;
            case 'HEATING':
                ignitionStatusText.textContent = 'Rozpalanie...';
                ignitionStatusText.classList.add('heating');
                if (igniterIndicator) igniterIndicator.style.display = 'flex';
                if (igniterIndicator) igniterIndicator.classList.remove('ready');
                ignitionTimerContainer.style.display = 'flex';
                ignitionProgressBar.style.display = 'flex';
                break;
            case 'READY':
                ignitionStatusText.textContent = 'Gotowy do Palenia';
                ignitionStatusText.classList.add('ready');
                if (igniterIndicator) igniterIndicator.style.display = 'flex';
                if (igniterIndicator) igniterIndicator.classList.add('ready');
                ignitionTimerContainer.style.display = 'flex';
                ignitionProgressBar.style.display = 'flex';
                break;
            case 'ON':
                ignitionStatusText.textContent = 'Płonie';
                ignitionStatusText.classList.add('on');
                ignitionTimerContainer.style.display = 'none';
                ignitionProgressBar.style.display = 'none';
                break;
            default:
                ignitionStatusText.textContent = '--';
                ignitionStatusText.classList.add('off');
                ignitionTimerContainer.style.display = 'none';
                ignitionProgressBar.style.display = 'none';
        }

        if (progressPercent !== null && ignitionProgressCircle && ignitionProgressText) {
            ignitionProgressCircle.style.background = `conic-gradient(#ff9800 0%, #ff5722 ${progressPercent}%, rgba(0,0,0,0.3) ${progressPercent}%)`;
            ignitionProgressText.textContent = `${Math.round(progressPercent)}%`;
        } else if (ignitionProgressCircle && ignitionProgressText) {
            ignitionProgressCircle.style.background = `conic-gradient(rgba(0,0,0,0.3) 100%)`;
            ignitionProgressText.textContent = `0%`;
        }

        if (currentTemp !== null && currentIgnitionTemp) {
            currentIgnitionTemp.textContent = `Akt. temp: ${currentTemp.toFixed(1)}°C`;
            currentIgnitionTemp.style.display = 'block';
        } else if (currentIgnitionTemp) {
            currentIgnitionTemp.style.display = 'none';
        }

        if (totalDuration !== null && remainingTime !== null && ignitionCountdown) {
            ignitionCountdown.textContent = formatTime(remainingTime);
        } else if (ignitionCountdown) {
            ignitionCountdown.textContent = '--:--';
        }
    }


    function updateFeederCycleInfo(state) {
        if (!feederCycleStatus || !feederCycleProgressBar || !feederCycleInfo) return;

        const cycleState = state.feederCycleState;
        const timeRemaining = state.timeRemainingInPhase; // seconds
        const currentPhaseDuration = state.currentPhaseDuration; // seconds

        let statusText = '--';
        let progress = 0;
        let infoText = `--s / --s`;
        let barColor = 'rgba(0,0,0,0.3)';

        if (cycleState === 'FEEDING_ON') {
            statusText = 'WŁ.';
            feederCycleStatus.classList.add('on');
            feederCycleStatus.classList.remove('off');
            progress = currentPhaseDuration > 0 ? ((currentPhaseDuration - timeRemaining) / currentPhaseDuration) * 100 : 0;
            infoText = `${(currentPhaseDuration - timeRemaining).toFixed(0)}s / ${currentPhaseDuration.toFixed(0)}s (ON)`;
            barColor = `linear-gradient(90deg, var(--feeder-forward-color) ${progress}%, rgba(0,0,0,0.3) ${progress}%)`;
        } else if (cycleState === 'FEEDING_OFF') {
            statusText = 'WYŁ.';
            feederCycleStatus.classList.add('off');
            feederCycleStatus.classList.remove('on');
            progress = currentPhaseDuration > 0 ? ((currentPhaseDuration - timeRemaining) / currentPhaseDuration) * 100 : 0;
            infoText = `${(currentPhaseDuration - timeRemaining).toFixed(0)}s / ${currentPhaseDuration.toFixed(0)}s (OFF)`;
            barColor = `linear-gradient(90deg, var(--feeder-pause-color) ${progress}%, rgba(0,0,0,0.3) ${progress}%)`;
        } else {
            statusText = 'Brak Cyklu';
            feederCycleStatus.classList.add('off');
            feederCycleStatus.classList.remove('on');
        }

        feederCycleStatus.textContent = statusText;
        feederCycleProgressBar.style.width = `${progress}%`;
        feederCycleProgressBar.style.background = barColor;
        feederCycleInfo.textContent = infoText;
    }

    function updateBlowerPurgeInfo(state) {
        if (!blowerPurgeStatus || !blowerPurgeProgressBar || !blowerPurgeInfo || !blowerPurgeModeText) return;

        const purgeState = state.blowerPurgeMode;
        const timeRemaining = state.blowerPurgeTimeRemaining; // seconds
        const totalDuration = state.blowerPurgeCurrentCycleDuration; // seconds

        let statusText = 'Wyłączony';
        let progress = 0;
        let infoText = `--s / --s`;
        let barColor = `linear-gradient(90deg, var(--blower-color) 0%, rgba(0,0,0,0.3) 0%)`;

        blowerPurgeStatus.classList.remove('on', 'off');
        blowerPurgeModeInfo.classList.remove('mode-direct', 'mode-inverter');

        if (purgeState === 'DIRECT' || purgeState === 'INVERTER') {
            const phaseProgress = totalDuration > 0 ? ((totalDuration - timeRemaining) / totalDuration) * 100 : 0;
            statusText = `WŁĄCZONY (${purgeState === 'DIRECT' ? 'Bezpośredni' : 'Inwerter'})`;
            blowerPurgeStatus.classList.add('on');
            infoText = `${(totalDuration - timeRemaining).toFixed(0)}s / ${totalDuration.toFixed(0)}s`;
            barColor = `linear-gradient(90deg, var(--blower-color) ${phaseProgress}%, rgba(0,0,0,0.3) ${phaseProgress}%)`;

            blowerPurgeModeInfo.classList.add(purgeState === 'DIRECT' ? 'mode-direct' : 'mode-inverter');
        } else {
            statusText = 'Wyłączony';
            blowerPurgeStatus.classList.add('off');
        }

        blowerPurgeStatus.textContent = statusText;
        blowerPurgeProgressBar.style.width = `${progress}%`; // For purge, progress bar might represent the 'on' time or total cycle
        blowerPurgeProgressBar.style.background = barColor;
        blowerPurgeInfo.textContent = infoText;
        blowerPurgeModeText.textContent = purgeState || '--';

        // Update active button for purge mode
        if (blowerPurgeModeOffBtn) blowerPurgeModeOffBtn.classList.toggle('active', purgeState === 'OFF');
        if (blowerPurgeModeDirectBtn) blowerPurgeModeDirectBtn.classList.toggle('active', purgeState === 'DIRECT');
        if (blowerPurgeModeInverterBtn) blowerPurgeModeInverterBtn.classList.toggle('active', purgeState === 'INVERTER');
    }


    function updateMaintenanceModeDisplay(isActive) {
        if (maintenanceModeIndicator) {
            if (isActive) {
                maintenanceModeIndicator.textContent = 'Aktywny';
                maintenanceModeIndicator.classList.remove('maintenance-inactive');
                maintenanceModeIndicator.classList.add('maintenance-active');
            } else {
                maintenanceModeIndicator.textContent = 'Nieaktywny';
                maintenanceModeIndicator.classList.remove('maintenance-active');
                maintenanceModeIndicator.classList.add('maintenance-inactive');
            }
        }

        // Show/hide maintenance sliders based on active state
        const sliders = [
            maintenanceFeedOnTimeSliderContainer,
            maintenanceFeedOffTimeSliderContainer,
            blowerMaintenanceManualPowerSliderContainer
        ];
        sliders.forEach(slider => {
            if (slider) slider.style.display = isActive ? 'block' : 'none';
        });
    }

    function updateBlowerManualControlDisplay(state) {
        if (!blowerControlModeText || !blowerControlModeInfo) return;

        const isManualControlActive = state.blowerManualControl;
        const currentMode = state.blowerControlMode || 'OFF'; // Assuming 'OFF', 'DIRECT', 'INVERTER'

        blowerControlModeText.textContent = currentMode;
        blowerControlModeInfo.classList.remove('mode-direct', 'mode-inverter');
        blowerManualControlToggle.checked = isManualControlActive;

        if (isManualControlActive) {
            if (currentMode === 'DIRECT') {
                blowerControlModeInfo.classList.add('mode-direct');
            } else if (currentMode === 'INVERTER') {
                blowerControlModeInfo.classList.add('mode-inverter');
            }
        }

        // Update active button for blower manual control mode
        if (blowerManualControlModeOff) blowerManualControlModeOff.classList.toggle('active', currentMode === 'OFF');
        if (blowerManualControlModeDirect) blowerManualControlModeDirect.classList.toggle('active', currentMode === 'DIRECT');
        if (blowerManualControlModeInverter) blowerManualControlModeInverter.classList.toggle('active', currentMode === 'INVERTER');
    }


    // --- MQTT Functions ---
    function connectMQTT() {
        const broker = mqttBrokerInput ? mqttBrokerInput.value : "broker.emqx.io";
        const port = mqttPortInput ? parseInt(mqttPortInput.value) : 8083;
        const user = mqttUserInput ? mqttUserInput.value : "agentsan007";
        const pass = mqttPasswordInput ? mqttPasswordInput.value : "Sanders24*";

        fullStateTopic = mqttTopicStateInput ? mqttTopicStateInput.value : "pellet/boiler/state";
        fullControlTopic = mqttTopicControlInput ? mqttTopicControlInput.value : "pellet/boiler/control";

        if (client && client.connected) {
            console.log("MQTT Client already connected.");
            return;
        }

        // Set up MQTT client with unique ID
        const clientId = 'web_client_' + Math.random().toString(16).substr(2, 8);
        client = mqtt.connect({
            host: broker,
            port: port,
            path: '/mqtt', // For WebSockets
            clientId: clientId,
            username: user,
            password: pass
        });

        client.on('connect', () => {
            logToApp('Połączono z brokerem MQTT!', 'success');
            mqttConnected = true;
            if (mqttStatusIndicator) mqttStatusIndicator.classList.add('connected');
            if (mqttStatusText) mqttStatusText.textContent = 'Połączono';
            if (mqttStatusBadge) {
                mqttStatusBadge.classList.remove('status-error');
                mqttStatusBadge.classList.add('status-good');
            }
            if (mqttStatusTextDiagram) mqttStatusTextDiagram.textContent = 'Połączono';

            client.subscribe(fullStateTopic, (err) => {
                if (!err) {
                    logToApp(`Subskrybowano temat: ${fullStateTopic}`, 'info');
                } else {
                    logToApp(`Błąd subskrypcji: ${err}`, 'error');
                }
            });
            // Request initial state after connecting
            publishCommand('request_state', {});
        });

        client.on('message', (topic, message) => {
            // console.log(`Received message from topic: ${topic}`);
            if (topic === fullStateTopic) {
                try {
                    const data = JSON.parse(message.toString());
                    // console.log("Parsed state data:", data);
                    updateUI(data);
                    currentState = data; // Store the latest state
                    logMqttMessage(topic, message.toString());
                } catch (e) {
                    logToApp(`Błąd parsowania JSON: ${e.message}`, 'error');
                    console.error("Error parsing JSON:", e, message.toString());
                }
            }
        });

        client.on('reconnect', () => {
            logToApp('Próba ponownego połączenia z MQTT...', 'warning');
            if (mqttStatusText) mqttStatusText.textContent = 'Łączenie...';
        });

        client.on('offline', () => {
            logToApp('Utracono połączenie z MQTT.', 'error');
            mqttConnected = false;
            if (mqttStatusIndicator) mqttStatusIndicator.classList.remove('connected');
            if (mqttStatusText) mqttStatusText.textContent = 'Rozłączono';
            if (mqttStatusBadge) {
                mqttStatusBadge.classList.remove('status-good');
                mqttStatusBadge.classList.add('status-error');
            }
            if (mqttStatusTextDiagram) mqttStatusTextDiagram.textContent = 'Rozłączono';
        });

        client.on('error', (err) => {
            logToApp(`Błąd MQTT: ${err.message}`, 'error');
            mqttConnected = false;
            if (mqttStatusIndicator) mqttStatusIndicator.classList.remove('connected');
            if (mqttStatusText) mqttStatusText.textContent = 'Błąd połączenia';
            if (mqttStatusBadge) {
                mqttStatusBadge.classList.remove('status-good');
                mqttStatusBadge.classList.add('status-error');
            }
            if (mqttStatusTextDiagram) mqttStatusTextDiagram.textContent = 'Błąd';
            client.end(); // Close the client to prevent continuous errors
        });
    }

    function disconnectMQTT() {
        if (client && client.connected) {
            client.end(() => {
                logToApp('Rozłączono z brokerem MQTT.', 'info');
                mqttConnected = false;
                if (mqttStatusIndicator) mqttStatusIndicator.classList.remove('connected');
                if (mqttStatusText) mqttStatusText.textContent = 'Rozłączono';
                if (mqttStatusBadge) {
                    mqttStatusBadge.classList.remove('status-good');
                    mqttStatusBadge.classList.add('status-error');
                }
                if (mqttStatusTextDiagram) mqttStatusTextDiagram.textContent = 'Rozłączono';
            });
        } else {
            logToApp('Klient MQTT nie jest połączony.', 'warning');
        }
    }

    function publishCommand(command, value) {
        if (mqttConnected) {
            const payload = JSON.stringify({
                command: command,
                value: value
            });
            client.publish(fullControlTopic, payload, (err) => {
                if (err) {
                    logToApp(`Błąd publikacji (${command}): ${err}`, 'error');
                } else {
                    logToApp(`Wysłano komendę: ${command} z wartością: ${JSON.stringify(value)}`, 'info');
                }
            });
        } else {
            logToApp('Błąd: Brak połączenia z MQTT. Nie można wysłać komendy.', 'error');
        }
    }

    // --- UI Update Function ---
    function updateUI(data) {
        if (boilerTempDisplay) boilerTempDisplay.textContent = data.boilerTemp !== undefined ? data.boilerTemp.toFixed(1) : '--.-';
        if (blowerPowerDisplay) blowerPowerDisplay.textContent = data.blowerPower !== undefined ? data.blowerPower : '--';
        if (flameStatusDisplay) flameStatusDisplay.textContent = data.flameOn ? 'Płonie' : 'Brak';
        updateFlameIndicator(data.flameOn); // Update visual flame indicator

        if (deltaTempDisplay) deltaTempDisplay.textContent = data.deltaTemp !== undefined ? data.deltaTemp.toFixed(1) : '--.-';
        if (blowerRPMDisplay) blowerRPMDisplay.textContent = data.blowerRPM !== undefined ? data.blowerRPM : '--';
        if (currentModeDisplay) currentModeDisplay.textContent = data.mode || '--';

        if (igniterPowerDisplay) igniterPowerDisplay.textContent = data.igniterPower !== undefined ? data.igniterPower : '--';
        if (burnerHoursTotalDisplay) burnerHoursTotalDisplay.textContent = data.burnerHoursTotal !== undefined ? data.burnerHoursTotal.toFixed(0) : '--';
        if (exhaustTempDisplay) exhaustTempDisplay.textContent = data.exhaustTemp !== undefined ? data.exhaustTemp.toFixed(1) : '--.-';
        if (wifiRSSIDisplay) wifiRSSIDisplay.textContent = data.wifiRSSI !== undefined ? data.wifiRSSI : '--';
        if (operatingTimeDisplay) operatingTimeDisplay.textContent = data.operatingTime !== undefined ? data.operatingTime.toFixed(0) : '--';
        if (reconnectCountDisplay) reconnectCountDisplay.textContent = data.reconnectCount !== undefined ? data.reconnectCount : '--';

        // Update slider values and displays if they are different
        if (targetTempSlider && data.targetTemp !== undefined && targetTempSlider.value != data.targetTemp) {
            targetTempSlider.value = data.targetTemp;
        }
        if (targetTempDisplay && data.targetTemp !== undefined) {
            targetTempDisplay.textContent = `${data.targetTemp}°C`;
        }

        if (fanPowerSlider && data.blowerPower !== undefined && fanPowerSlider.value != data.blowerPower) {
            fanPowerSlider.value = data.blowerPower;
        }
        if (fanPowerDisplay && data.blowerPower !== undefined) {
            fanPowerDisplay.textContent = `${data.blowerPower}%`;
        }

        if (feederSpeedSlider && data.feederSpeed !== undefined && feederSpeedSlider.value != data.feederSpeed) {
            feederSpeedSlider.value = data.feederSpeed;
        }
        if (feederSpeedDisplay && data.feederSpeed !== undefined) {
            feederSpeedDisplay.textContent = `${data.feederSpeed}s`;
        }

        if (ignitionTimeInput && data.ignitionTime !== undefined && ignitionTimeInput.value != data.ignitionTime) {
            ignitionTimeInput.value = data.ignitionTime;
        }
        if (stabilizationTimeInput && data.stabilizationTime !== undefined && stabilizationTimeInput.value != data.stabilizationTime) {
            stabilizationTimeInput.value = data.stabilizationTime;
        }

        // Update active mode buttons
        if (modeOffButton) modeOffButton.classList.toggle('active', data.mode === 'OFF');
        if (modeManualButton) modeManualButton.classList.toggle('active', data.mode === 'MANUAL');
        if (modeAutoButton) modeAutoButton.classList.toggle('active', data.mode === 'AUTO');

        // Update auto-clean settings
        if (autoCleanToggle && data.autoCleanEnabled !== undefined) {
            autoCleanToggle.checked = data.autoCleanEnabled;
        }
        if (cleanIntervalHoursInput && data.cleanIntervalHours !== undefined) {
            cleanIntervalHoursInput.value = data.cleanIntervalHours;
        }
        if (cleanDurationMinutesInput && data.cleanDurationMinutes !== undefined) {
            cleanDurationMinutesInput.value = data.cleanDurationMinutes;
        }
        if (cleanBlowerPowerInput && data.cleanBlowerPower !== undefined) {
            cleanBlowerPowerInput.value = data.cleanBlowerPower;
        }

        // Update maintenance mode
        if (maintenanceModeToggle && data.maintenanceMode !== undefined) {
            maintenanceModeToggle.checked = data.maintenanceMode;
            updateMaintenanceModeDisplay(data.maintenanceMode);
        }
        if (maintenanceFeedOnTimeSlider && data.maintenanceFeedOnTime !== undefined && maintenanceFeedOnTimeSlider.value != data.maintenanceFeedOnTime) {
            maintenanceFeedOnTimeSlider.value = data.maintenanceFeedOnTime;
        }
        if (maintenanceFeedOnTimeDisplay && data.maintenanceFeedOnTime !== undefined) {
            maintenanceFeedOnTimeDisplay.textContent = `${data.maintenanceFeedOnTime}s`;
        }
        if (maintenanceFeedOffTimeSlider && data.maintenanceFeedOffTime !== undefined && maintenanceFeedOffTimeSlider.value != data.maintenanceFeedOffTime) {
            maintenanceFeedOffTimeSlider.value = data.maintenanceFeedOffTime;
        }
        if (maintenanceFeedOffTimeDisplay && data.maintenanceFeedOffTime !== undefined) {
            maintenanceFeedOffTimeDisplay.textContent = `${data.maintenanceFeedOffTime}s`;
        }
        if (blowerMaintenanceManualPowerSlider && data.blowerMaintenanceManualPower !== undefined && blowerMaintenanceManualPowerSlider.value != data.blowerMaintenanceManualPower) {
            blowerMaintenanceManualPowerSlider.value = data.blowerMaintenanceManualPower;
        }
        if (blowerMaintenanceManualPowerDisplay && data.blowerMaintenanceManualPower !== undefined) {
            blowerMaintenanceManualPowerDisplay.textContent = `${data.blowerMaintenanceManualPower}%`;
        }

        // Update blower manual control
        if (blowerManualControlToggle && data.blowerManualControl !== undefined) {
            blowerManualControlToggle.checked = data.blowerManualControl;
            updateBlowerManualControlDisplay(data); // Pass full data to update mode buttons as well
        }
        if (blowerWorkPowerSlider && data.blowerWorkPower !== undefined && blowerWorkPowerSlider.value != data.blowerWorkPower) {
            blowerWorkPowerSlider.value = data.blowerWorkPower;
        }
        if (blowerWorkPowerDisplay && data.blowerWorkPower !== undefined) {
            blowerWorkPowerDisplay.textContent = `${data.blowerWorkPower}%`;
        }

        // Update temperature correction
        if (tempCorrectionDisplay) tempCorrectionDisplay.textContent = data.tempCorrection !== undefined ? `${data.tempCorrection.toFixed(1)} °C` : '0.0 °C';
        if (tempCorrectionInput && data.tempCorrection !== undefined && tempCorrectionInput.value != data.tempCorrection) {
            tempCorrectionInput.value = data.tempCorrection.toFixed(1);
        }

        // Update Feeder Cycle Info
        updateFeederCycleInfo(data);

        // Update Blower Purge Info
        if (blowerPurgeOnTimeInput && data.blowerPurgeOnTime !== undefined) blowerPurgeOnTimeInput.value = data.blowerPurgeOnTime;
        if (blowerPurgeOffTimeInput && data.blowerPurgeOffTime !== undefined) blowerPurgeOffTimeInput.value = data.blowerPurgeOffTime;
        if (blowerPurgeManualPowerSlider && data.blowerPurgeManualPower !== undefined) {
            blowerPurgeManualPowerSlider.value = data.blowerPurgeManualPower;
        }
        if (blowerPurgeManualPowerDisplay && data.blowerPurgeManualPower !== undefined) {
            blowerPurgeManualPowerDisplay.textContent = `${data.blowerPurgeManualPower}%`;
        }
        updateBlowerPurgeInfo(data);

        // Update Ignition Status based on received data
        const igniterState = data.igniterState; // Assuming this comes from ESP32: "OFF", "HEATING", "READY", "ON"
        const ignitionProgress = data.ignitionProgress !== undefined ? data.ignitionProgress : 0; // 0-100%
        const ignitionTemp = data.ignitionTemp !== undefined ? data.ignitionTemp : null;
        const timeRemainingInPhase = data.timeRemainingInPhase !== undefined ? data.timeRemainingInPhase : null; // Seconds
        const currentPhaseDuration = data.currentPhaseDuration !== undefined ? data.currentPhaseDuration : null; // Seconds

        updateIgnitionStatus(igniterState, ignitionProgress, ignitionTemp, currentPhaseDuration, timeRemainingInPhase);


        // Update Wi-Fi and ESP32 Status
        if (wifiStatusText) {
            if (data.wifiRSSI !== undefined && data.wifiRSSI !== -999) { // Assuming -999 is an invalid value
                wifiStatusText.textContent = `Połączono (${data.wifiRSSI} dBm)`;
                wifiStatusBadge.classList.remove('status-error');
                wifiStatusBadge.classList.add('status-good');
            } else {
                wifiStatusText.textContent = 'Brak połączenia';
                wifiStatusBadge.classList.remove('status-good');
                wifiStatusBadge.classList.add('status-error');
            }
        }
        // MQTT status is updated by MQTT client events

        if (espStatusText) {
            if (data.timestamp_ms > 0 && (Date.now() - data.timestamp_ms) < 30000) { // Data received in last 30 seconds
                espStatusText.textContent = 'Online';
                espStatusBadge.classList.remove('status-error');
                espStatusBadge.classList.add('status-good');
            } else {
                espStatusText.textContent = 'Offline / Brak danych';
                espStatusBadge.classList.remove('status-good');
                espStatusBadge.classList.add('status-error');
            }
        }

        // Update Device Status grid
        const getStatusText = (value) => value ? 'OK' : 'Błąd';
        const getStatusClass = (value) => value ? 'status-active' : 'status-inactive';

        if (boilerSensorStatus) {
            boilerSensorStatus.textContent = getStatusText(data.boilerSensorOk);
            boilerSensorStatus.className = `status-value ${getStatusClass(data.boilerSensorOk)}`;
        }
        if (exhaustSensorStatus) {
            exhaustSensorStatus.textContent = getStatusText(data.exhaustSensorOk);
            exhaustSensorStatus.className = `status-value ${getStatusClass(data.exhaustSensorOk)}`;
        }
        if (igniterStatus) {
            igniterStatus.textContent = data.igniterState === 'ON' || data.igniterState === 'HEATING' || data.igniterState === 'READY' ? 'WŁ./Grzeje' : 'Wył.';
            igniterStatus.className = `status-value ${data.igniterState === 'ON' || data.igniterState === 'HEATING' || data.igniterState === 'READY' ? 'status-active' : 'status-inactive'}`;
        }
        if (blowerStatusDevice) {
            blowerStatusDevice.textContent = data.blowerPower > 0 ? 'WŁ.' : 'Wył.';
            blowerStatusDevice.className = `status-value ${data.blowerPower > 0 ? 'status-active' : 'status-inactive'}`;
        }
        if (feederStatus) {
            feederStatus.textContent = data.feederCycleState === 'FEEDING_ON' ? 'WŁ.' : 'Wył.';
            feederStatus.className = `status-value ${data.feederCycleState === 'FEEDING_ON' ? 'status-active' : 'status-inactive'}`;
        }


        // Update Chart Data
        const timestamp = data.timestamp_ms ? data.timestamp_ms : (data.timestamp * 1000 || Date.now()); // Prefer ms timestamp from ESP32
        const date = new Date(timestamp);

        // Add only if data is new (prevent duplicates) and within reasonable bounds
        const lastChartTimestamp = chartData.timestamp.length > 0 ? chartData.timestamp[chartData.timestamp.length - 1] : 0;
        if (timestamp > lastChartTimestamp) { // Add only if newer than last point
            chartData.timestamp.push(timestamp);
            chartData.boilerTemp.push(data.boilerTemp);
            chartData.exhaustTemp.push(data.exhaustTemp);
            chartData.targetTemp.push(data.targetTemp);

            // Keep only a certain number of points for live view or filter for specific ranges
            // For 'live' mode, keep a reasonable amount, e.g., last 30 minutes (30 points if 1 point/min)
            // Or simply keep a rolling window for live data
            const maxLivePoints = 120; // e.g., 2 hours if updates every minute
            if (currentChartMode === 'live' && chartData.timestamp.length > maxLivePoints) {
                chartData.timestamp.shift();
                chartData.boilerTemp.shift();
                chartData.exhaustTemp.shift();
                chartData.targetTemp.shift();
            }

            // Log to chart log
            const timeStr = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            logToChart(`${timeStr} - Kocioł: ${data.boilerTemp !== undefined ? data.boilerTemp.toFixed(1) : '--'}°C, Spaliny: ${data.exhaustTemp !== undefined ? data.exhaustTemp.toFixed(1) : '--'}°C`);
        }
        updateChart(); // Update chart whenever new data arrives
        calculateCost(); // Recalculate cost with potentially new data
    }


    // --- Event Listeners ---
    if (targetTempSlider) {
        targetTempSlider.oninput = () => {
            if (targetTempDisplay) targetTempDisplay.textContent = `${targetTempSlider.value}°C`;
        };
        targetTempSlider.onchange = () => {
            publishCommand('set_target_temp', parseFloat(targetTempSlider.value));
        };
    }

    if (fanPowerSlider) {
        fanPowerSlider.oninput = () => {
            if (fanPowerDisplay) fanPowerDisplay.textContent = `${fanPowerSlider.value}%`;
        };
        fanPowerSlider.onchange = () => {
            publishCommand('set_blower_power', parseInt(fanPowerSlider.value));
        };
    }

    if (feederSpeedSlider) {
        feederSpeedSlider.oninput = () => {
            if (feederSpeedDisplay) feederSpeedDisplay.textContent = `${feederSpeedSlider.value}s`;
        };
        feederSpeedSlider.onchange = () => {
            publishCommand('set_feeder_speed', parseInt(feederSpeedSlider.value));
        };
    }

    if (modeOffButton) modeOffButton.onclick = () => publishCommand('set_mode', 'OFF');
    if (modeManualButton) modeManualButton.onclick = () => publishCommand('set_mode', 'MANUAL');
    if (modeAutoButton) modeAutoButton.onclick = () => publishCommand('set_mode', 'AUTO');

    if (igniteButton) igniteButton.onclick = () => {
        const ignitionTime = parseInt(ignitionTimeInput.value);
        const stabilizationTime = parseInt(stabilizationTimeInput.value);
        if (isNaN(ignitionTime) || isNaN(stabilizationTime)) {
            logToApp('Wprowadź poprawne czasy rozpalania i stabilizacji.', 'error');
            return;
        }
        publishCommand('ignite', {
            ignitionTime: ignitionTime,
            stabilizationTime: stabilizationTime
        });
    };
    if (stopBurnerButton) stopBurnerButton.onclick = () => publishCommand('stop_burner', {});


    if (updateCleanBtn) {
        updateCleanBtn.onclick = () => {
            const interval = parseInt(cleanIntervalHoursInput.value);
            const duration = parseInt(cleanDurationMinutesInput.value);
            const power = parseInt(cleanBlowerPowerInput.value);
            if (isNaN(interval) || isNaN(duration) || isNaN(power)) {
                logToApp('Wprowadź poprawne wartości dla auto-czyszczenia.', 'error');
                return;
            }
            publishCommand('set_auto_clean_params', {
                intervalHours: interval,
                durationMinutes: duration,
                blowerPower: power
            });
        };
    }

    if (autoCleanToggle) {
        autoCleanToggle.onchange = () => {
            publishCommand('set_auto_clean_enabled', autoCleanToggle.checked);
        };
    }

    if (maintenanceModeToggle) {
        maintenanceModeToggle.onchange = () => {
            publishCommand('set_maintenance_mode', maintenanceModeToggle.checked);
            // Sliders will be hidden/shown by updateMaintenanceModeDisplay on state update
        };
    }

    if (maintenanceFeedOnTimeSlider) {
        maintenanceFeedOnTimeSlider.oninput = () => {
            if (maintenanceFeedOnTimeDisplay) maintenanceFeedOnTimeDisplay.textContent = `${maintenanceFeedOnTimeSlider.value}s`;
        };
        maintenanceFeedOnTimeSlider.onchange = () => {
            publishCommand('set_maintenance_feed_on', parseInt(maintenanceFeedOnTimeSlider.value));
        };
    }
    if (maintenanceFeedOffTimeSlider) {
        maintenanceFeedOffTimeSlider.oninput = () => {
            if (maintenanceFeedOffTimeDisplay) maintenanceFeedOffTimeDisplay.textContent = `${maintenanceFeedOffTimeSlider.value}s`;
        };
        maintenanceFeedOffTimeSlider.onchange = () => {
            publishCommand('set_maintenance_feed_off', parseInt(maintenanceFeedOffTimeSlider.value));
        };
    }
    if (blowerMaintenanceManualPowerSlider) {
        blowerMaintenanceManualPowerSlider.oninput = () => {
            if (blowerMaintenanceManualPowerDisplay) blowerMaintenanceManualPowerDisplay.textContent = `${blowerMaintenanceManualPowerSlider.value}%`;
        };
        blowerMaintenanceManualPowerSlider.onchange = () => {
            publishCommand('set_blower_maintenance_power', parseInt(blowerMaintenanceManualPowerSlider.value));
        };
    }

    if (blowerManualControlToggle) {
        blowerManualControlToggle.onchange = () => {
            publishCommand('set_blower_manual_control', blowerManualControlToggle.checked);
            // Mode buttons will be updated on state update
        };
    }
    if (blowerManualControlModeOff) blowerManualControlModeOff.onclick = () => publishCommand('set_blower_control_mode', 'OFF');
    if (blowerManualControlModeDirect) blowerManualControlModeDirect.onclick = () => publishCommand('set_blower_control_mode', 'DIRECT');
    if (blowerManualControlModeInverter) blowerManualControlModeInverter.onclick = () => publishCommand('set_blower_control_mode', 'INVERTER');


    if (blowerWorkPowerSlider) {
        blowerWorkPowerSlider.oninput = () => {
            if (blowerWorkPowerDisplay) blowerWorkPowerDisplay.textContent = `${blowerWorkPowerSlider.value}%`;
        };
        blowerWorkPowerSlider.onchange = () => {
            publishCommand('set_blower_work_power', parseInt(blowerWorkPowerSlider.value));
        };
    }

    if (tempCorrectionInput && setTempCorrectionBtn) {
        setTempCorrectionBtn.onclick = () => {
            const correction = parseFloat(tempCorrectionInput.value);
            if (!isNaN(correction)) {
                publishCommand('set_temp_correction', correction);
            } else {
                logToApp('Wprowadź prawidłową wartość korekcji temperatury.', 'error');
            }
        };
    }

    // Blower Purge Control Listeners
    if (blowerPurgeOnTimeInput) {
        blowerPurgeOnTimeInput.onchange = () => {
            const value = parseInt(blowerPurgeOnTimeInput.value);
            if (!isNaN(value)) publishCommand('set_blower_purge_on_time', value);
        };
    }
    if (blowerPurgeOffTimeInput) {
        blowerPurgeOffTimeInput.onchange = () => {
            const value = parseInt(blowerPurgeOffTimeInput.value);
            if (!isNaN(value)) publishCommand('set_blower_purge_off_time', value);
        };
    }
    if (blowerPurgeManualPowerSlider) {
        blowerPurgeManualPowerSlider.oninput = () => {
            if (blowerPurgeManualPowerDisplay) blowerPurgeManualPowerDisplay.textContent = `${blowerPurgeManualPowerSlider.value}%`;
        };
        blowerPurgeManualPowerSlider.onchange = () => {
            const value = parseInt(blowerPurgeManualPowerSlider.value);
            if (!isNaN(value)) publishCommand('set_blower_purge_manual_power', value);
        };
    }
    if (blowerPurgeModeOffBtn) blowerPurgeModeOffBtn.onclick = () => publishCommand('set_blower_purge_mode', 'OFF');
    if (blowerPurgeModeDirectBtn) blowerPurgeModeDirectBtn.onclick = () => publishCommand('set_blower_purge_mode', 'DIRECT');
    if (blowerPurgeModeInverterBtn) blowerPurgeModeInverterBtn.onclick = () => publishCommand('set_blower_purge_mode', 'INVERTER');


    if (resetStatisticsButton) {
        resetStatisticsButton.onclick = () => {
            if (confirm('Czy na pewno chcesz zresetować statystyki czasu pracy palnika i zużycia pelletu? Tej operacji nie można cofnąć!')) {
                publishCommand('reset_statistics', {});
            }
        };
    }

    if (resetAllDataButton) {
        resetAllDataButton.onclick = () => {
            const password = prompt('Aby zresetować WSZYSTKIE dane, podaj hasło MQTT (Sanders24*):');
            if (password === (mqttPasswordInput ? mqttPasswordInput.value : "Sanders24*")) {
                publishCommand('reset_all_data', {});
                logToApp('Wysłano komendę resetowania wszystkich danych.', 'warning');
            } else {
                logToApp('Nieprawidłowe hasło. Resetowanie anulowane.', 'error');
            }
        };
    }

    // --- Logging Functions ---
    function logToApp(message, type = 'info') {
        const logContainer = document.getElementById('appLog');
        if (!logContainer) return;
        const now = new Date();
        const timeStr = now.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const entry = document.createElement('div');
        entry.classList.add('log-entry');
        entry.innerHTML = `<span class="log-time">${timeStr}</span> <span class="log-message ${type}">${message}</span>`;
        logContainer.prepend(entry); // Add to top
        if (logContainer.children.length > 50) { // Keep log concise
            logContainer.removeChild(logContainer.lastChild);
        }
    }

    function logMqttMessage(topic, message) {
        const logContainer = document.getElementById('mqttLog'); // Assuming you have a div with id="mqttLog"
        if (!logContainer) return;
        const now = new Date();
        const timeStr = now.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const entry = document.createElement('div');
        entry.classList.add('mqtt-log-entry');
        entry.innerHTML = `<span class="log-time">${timeStr}</span> <span class="mqtt-log-topic">${topic}:</span> <span class="mqtt-log-message">${message}</span>`;
        logContainer.prepend(entry);
        if (logContainer.children.length > 30) {
            logContainer.removeChild(logContainer.lastChild);
        }
    }

    function logToChart(message) {
        if (!chartLog) return;
        const now = new Date();
        const timeStr = now.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const entry = document.createElement('div');
        entry.classList.add('log-entry');
        entry.innerHTML = `<span class="log-time">${timeStr}</span> <span class="log-message">${message}</span>`;
        chartLog.prepend(entry); // Add to top
        if (chartLog.children.length > 20) { // Keep log concise
            chartLog.removeChild(chartLog.lastChild);
        }
    }

    // --- Chart Functions ---
    function initChart(initialData) {
        const ctx = document.getElementById('myChart').getContext('2d');
        myChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [], // Will be timestamps
                datasets: [{
                    label: 'Temp. Kotła (°C)',
                    data: [],
                    borderColor: '#3498db',
                    tension: 0.1,
                    fill: false,
                    hidden: false, // Default visible
                    yAxisID: 'y'
                }, {
                    label: 'Temp. Spalin (°C)',
                    data: [],
                    borderColor: '#e74c3c',
                    tension: 0.1,
                    fill: false,
                    hidden: false, // Default visible
                    yAxisID: 'y'
                }, {
                    label: 'Temp. Docelowa (°C)',
                    data: [],
                    borderColor: '#2ecc71',
                    tension: 0.1,
                    fill: false,
                    hidden: false, // Default visible
                    yAxisID: 'y'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: currentChartMode === 'live' ? 'minute' : (currentChartMode === 'day' ? 'hour' : 'day'),
                            tooltipFormat: 'yyyy-MM-dd HH:mm',
                            displayFormats: {
                                minute: 'HH:mm',
                                hour: 'HH:mm',
                                day: 'MMM d',
                                week: 'MMM d',
                                month: 'MMM yyyy'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Czas',
                            color: 'white'
                        },
                        ticks: {
                            color: 'white'
                        },
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Temperatura (°C)',
                            color: 'white'
                        },
                        ticks: {
                            color: 'white'
                        },
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(context) {
                                return Luxon.DateTime.fromMillis(context[0].parsed.x).toFormat('yyyy-MM-dd HH:mm:ss');
                            }
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x',
                            threshold: 10
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'x',
                        }
                    }
                },
                animation: {
                    duration: 0 // Disable animation for smoother real-time updates
                }
            }
        });

        // Initialize with data from chartData cache
        updateChart();
    }

    function updateChart() {
        if (!myChart) return;

        // Clear existing data (important for mode changes)
        myChart.data.labels = [];
        myChart.data.datasets[0].data = []; // boilerTemp
        myChart.data.datasets[1].data = []; // exhaustTemp
        myChart.data.datasets[2].data = []; // targetTemp

        // Populate with current chartData cache
        for (let i = 0; i < chartData.timestamp.length; i++) {
            myChart.data.labels.push(chartData.timestamp[i]);
            myChart.data.datasets[0].data.push(chartData.boilerTemp[i]);
            myChart.data.datasets[1].data.push(chartData.exhaustTemp[i]);
            myChart.data.datasets[2].data.push(chartData.targetTemp[i]);
        }

        // Apply dataset visibility based on activeChartDatasetIds
        myChart.data.datasets.forEach(dataset => {
            const datasetId = Object.keys(chartData).find(key => dataset.label.includes(key.replace('Temp', ' Temp'))); // Crude way to match label to ID
            if (datasetId) {
                dataset.hidden = !activeChartDatasetIds.includes(datasetId);
            }
        });

        // Update x-axis unit based on currentChartMode
        let unit = 'minute';
        let tooltipFormat = 'yyyy-MM-dd HH:mm:ss';
        let displayFormats = {
            minute: 'HH:mm',
            hour: 'HH:mm',
            day: 'MMM d',
            week: 'MMM d',
            month: 'MMM yyyy'
        };

        if (currentChartMode === 'day') {
            unit = 'hour';
            tooltipFormat = 'yyyy-MM-dd HH:mm';
            displayFormats.hour = 'HH:mm';
        } else if (currentChartMode === 'week' || currentChartMode === 'month') {
            unit = 'day';
            tooltipFormat = 'yyyy-MM-dd';
        }

        myChart.options.scales.x.time.unit = unit;
        myChart.options.scales.x.time.tooltipFormat = tooltipFormat;
        myChart.options.scales.x.time.displayFormats = displayFormats;

        myChart.update();
    }

    // Toggle dataset visibility from chart controls
    if (datasetToggles) {
        datasetToggles.forEach(toggle => {
            toggle.addEventListener('click', () => {
                const datasetId = toggle.dataset.dataset;
                if (activeChartDatasetIds.includes(datasetId)) {
                    activeChartDatasetIds = activeChartDatasetIds.filter(id => id !== datasetId);
                    toggle.classList.remove('active');
                } else {
                    activeChartDatasetIds.push(datasetId);
                    toggle.classList.add('active');
                }
                updateChart();
            });
        });
    }

    // Chart mode switcher (Live, Day, Week, Month)
    if (chartTypeSwitcher) {
        chartTypeSwitcher.querySelectorAll('.chart-switch').forEach(btn => {
            btn.addEventListener('click', () => {
                chartTypeSwitcher.querySelectorAll('.chart-switch').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentChartMode = btn.dataset.chart;

                if (currentChartMode === 'live') {
                    // For live, use existing chartData, it's already a rolling window
                    updateChart();
                    logToApp('Przełączono na widok Live.', 'info');
                } else {
                    // For historical data, fetch from ESP32/server
                    logToApp(`Pobieranie danych historycznych dla trybu: ${currentChartMode}...`, 'info');
                    publishCommand('request_historical_data', currentChartMode);
                    // ESP32 should send 'historical_data' MQTT message
                }
            });
        });
    }

    if (zoomInBtn) zoomInBtn.addEventListener('click', () => myChart.zoom(1.1));
    if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => myChart.zoom(0.9));
    if (resetZoomBtn) resetZoomBtn.addEventListener('click', () => myChart.resetZoom());

    // Tabs functionality
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');

    if (tabs && tabContents) {
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTabId = tab.dataset.tab;

                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(tc => tc.classList.remove('active'));

                tab.classList.add('active');
                document.getElementById(targetTabId).classList.add('active');

                // If switching to chart tab, ensure chart updates
                if (targetTabId === 'chart-tab' && myChart) {
                    myChart.resize(); // Re-render chart if container size changed
                    updateChart();
                }
            });
        });
    }

    // History range selection (Day, Week, Month for stats)
    if (historyRangeBtns) {
        historyRangeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                historyRangeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentHistoryRange = btn.dataset.range;
                logToApp(`Pobieranie statystyk historycznych dla zakresu: ${currentHistoryRange}...`, 'info');
                publishCommand('request_history_stats', currentHistoryRange); // Request new stats from ESP32
            });
        });
    }

    function calculateCost() {
        const price = parseFloat(pelletPriceInput ? pelletPriceInput.value : 1.50);
        const actualConsumptionRate = currentState.currentPelletConsumptionRate || 0; // kg/min
        const burnerHoursTotal = currentState.burnerHoursTotal || 0; // minutes

        if (!isNaN(price) && price > 0) {
            if (estimatedConsumptionDisplay) estimatedConsumptionDisplay.textContent = `${(actualConsumptionRate * 60).toFixed(2)} kg/h`; // Show rate per hour
            if (!isNaN(actualConsumptionRate) && !isNaN(burnerHoursTotal)) {
                const estimatedCost = price * actualConsumptionRate * burnerHoursTotal; // burnerHoursTotal is in minutes, actualConsumptionRate is kg/min
                if (estimatedCostDisplay) estimatedCostDisplay.textContent = `${estimatedCost.toFixed(2)} PLN`;
                if (totalCalculatedCost) totalCalculatedCost.textContent = `${estimatedCost.toFixed(2)} PLN`;
            } else {
                if (estimatedCostDisplay) estimatedCostDisplay.textContent = `N/A`;
                if (totalCalculatedCost) totalCalculatedCost.textContent = `N/A`;
            }
        } else {
            if (estimatedConsumptionDisplay) estimatedConsumptionDisplay.textContent = `N/A`;
            if (estimatedCostDisplay) estimatedCostDisplay.textContent = `N/A`;
            if (totalCalculatedCost) totalCalculatedCost.textContent = `N/A`;
        }
    }

    if (pelletPriceInput) pelletPriceInput.addEventListener('input', calculateCost);


    // Initial state fetch and MQTT connection
    if (mqttConnectBtn) mqttConnectBtn.addEventListener('click', connectMQTT);
    if (mqttDisconnectBtn) mqttDisconnectBtn.addEventListener('click', disconnectMQTT);

    // Inicjalizacja wykresów
    initChart([]); // Inicjalizuj wykresy po załadowaniu DOM

    // AUTOMATYCZNE POŁĄCZENIE MQTT PO ZAŁADOWANIU STRONY (dla połączenia internetowego)
    connectMQTT();

});
