document.addEventListener('DOMContentLoaded', () => {
    console.log('DOMContentLoaded fired.');

    let client = null;
    let isMqttConnected = false;

    const MQTT_TOPICS = {
        state: "pellet/boiler/state",
        control: "pellet/boiler/control",
        targetTemp: "pellet/boiler/target_temp",
        power: "pellet/boiler/power"
    };

    const mqttBrokerInput = document.getElementById('mqtt-broker');
    const mqttPortInput = document.getElementById('mqtt-port');
    const mqttUsernameInput = document.getElementById('mqtt-username');
    const mqttPasswordInput = document.getElementById('mqtt-password');
    const mqttConnectBtn = document.getElementById('mqtt-connect-btn');
    const mqttDisconnectBtn = document.getElementById('mqtt-disconnect-btn');
    const mqttStatusIndicator = document.getElementById('mqtt-status-indicator');
    const mqttStatusText = document.getElementById('mqtt-status-text');
    const mqttLogDiv = document.getElementById('mqtt-log');

    const powerBtn = document.getElementById('power-btn');
    const targetSlider = document.getElementById('target-slider');
    const targetDisplay = document.getElementById('target-display');
    const targetTemp = document.getElementById('target-temp');

    const waterTempDisplay = document.getElementById('water-temp');
    const roomTempDisplay = document.getElementById('room-temp');
    const burnerTempDisplay = document.getElementById('burner-temp');
    const exhaustTempDisplay = document.getElementById('exhaust-temp');
    const waterProgressBar = document.getElementById('water-progress');
    const flameIndicator = document.getElementById('flame-indicator');
    
    const feederStatusIndicatorMini = document.getElementById('feeder-status-indicator-mini');
    const blowerStatusIndicatorMini = document.getElementById('blower-status-indicator-mini');
    const maintenanceStatus = document.getElementById('maintenance-status');
    const maintenanceStatusBadge = document.getElementById('maintenance-status-badge');
    const ashCleaningStatus = document.getElementById('ash-cleaning-status');
    const cleaningStatusBadge = document.getElementById('cleaning-status-badge');
    const igniterIndicator = document.getElementById('igniter-indicator');
    const igniterStatusText = document.getElementById('igniter-status-text');
    const igniterTempDisplay = document.getElementById('igniter-temp-display');
    const feederStatus = document.getElementById('feeder-status');
    const cycleProgressBar = document.getElementById('cycle-progress-bar');
    const cycleTimer = document.getElementById('cycle-timer');
    const pelletAmount = document.getElementById('pellet-amount');
    const averagePelletConsumptionDisplay = document.getElementById('average-pellet-consumption');

    const feedTimeInput = document.getElementById('feed-time');
    const pauseTimeInput = document.getElementById('pause-time');
    const maintenanceFeedInput = document.getElementById('maintenance-feed');
    const maintenancePauseInput = document.getElementById('maintenance-pause');

    const blowerManualControlsDiv = document.getElementById('blower-manual-controls');
    const blowerManualToggle = document.getElementById('blower-manual-toggle');
    const blowerWorkPowerSlider = document.getElementById('blower-work-power-slider');
    const blowerWorkPowerDisplay = document.getElementById('blower-work-power-display');
    const blowerMaintenanceManualPowerSlider = document.getElementById('blower-maintenance-manual-power-slider');
    const blowerMaintenanceManualPowerDisplay = document.getElementById('blower-maintenance-manual-power-display');
    const blowerPurgeManualPowerSlider = document.getElementById('blower-purge-manual-power-slider');
    const blowerPurgeManualPowerDisplay = document.getElementById('blower-purge-manual-power-display');
    const blowerPowerSlider = document.getElementById('blower-power-slider');
    const blowerPowerDisplay = document.getElementById('blower-power-display');
    const blowerPurgeToggle = document.getElementById('blower-purge-toggle');
    const blowerPurgeTimesContainer = document.getElementById('blower-purge-times');
    const blowerPurgeOnInput = document.getElementById('blower-purge-on');
    const blowerPurgeOffInput = document.getElementById('blower-purge-off');

    const sessionUptimeDisplay = document.getElementById('session-uptime');
    const totalUptimeDisplay = document.getElementById('total-uptime');
    const rssi = document.getElementById('rssi');
    const ipAddr = document.getElementById('ip-addr');

    const burnerHoursDisplay = document.getElementById('burner-hours');
    const estimatedCostDisplay = document.getElementById('estimated-cost');
    const pelletPriceInput = document.getElementById('pellet-price');
    const pelletConsumptionInput = document.getElementById('pellet-consumption');
    const totalCalculatedCost = document.getElementById('total-calculated-cost');
    const efficiencyFill = document.getElementById('efficiency-fill');
    const efficiencyLabel = document.getElementById('efficiency-label');

    const cleanHoursInput = document.getElementById('clean-hours');
    const cleanMinutesInput = document.getElementById('clean-minutes');
    const cleanSecondsInput = document.getElementById('clean-seconds');
    const updateCleanBtn = document.getElementById('update-clean-btn');
    const cleanCountdownDisplay = document.getElementById('clean-countdown-display');

    const ashBtn = document.getElementById('ash-btn');
    const resetSessionUptimeBtn = document.getElementById('reset-session-uptime-btn');
    const resetHistoryBtn = document.getElementById('reset-history-btn');
    const resetPasswordInput = document.getElementById('reset-password');
    const resetMessageDiv = document.getElementById('reset-message');
    
    const temperatureChartToggles = document.getElementById('temperature-chart-toggles');
    const mainChartSwitcher = document.getElementById('main-chart-switcher');
    const chartContainerTemp = document.getElementById('chart-container-temp');
    const chartContainerConsumption = document.getElementById('chart-container-consumption');
    const chartContainerDailyConsumption = document.getElementById('chart-container-daily-consumption');
    const chartContainerMonthlyConsumption = document.getElementById('chart-container-monthly-consumption');
    const chartContainerYearlyConsumption = document.getElementById('chart-container-yearly-consumption');
    const chartContainerGlobalConsumption = document.getElementById('chart-container-global-consumption');
    const historyRangeButtons = document.querySelectorAll('.history-btn');

    let temperatureChartInstance, consumptionChartInstance, dailyConsumptionChartInstance, monthlyConsumptionChartInstance, yearlyConsumptionChartInstance, globalConsumptionChartInstance;

    const chartData = {
        water_temp: [],
        room_temp: [],
        burner_temp: [],
        exhaust_temp: [],
        pellet_consumption: []
    };
    const chartDatasetMap = {
        'water_temp': 0,
        'room_temp': 1,
        'burner_temp': 2,
        'exhaust_temp': 3
    };

    function appendMqttLog(topic, message, type = 'received') {
        const now = new Date();
        const time = now.toTimeString().split(' ')[0].substring(0, 8);
        const logEntry = document.createElement('div');
        logEntry.classList.add('mqtt-log-entry');
        let messageClass = 'mqtt-log-message';
        if (type === 'sent') messageClass += ' mqtt-log-sent';
        else if (type === 'error') messageClass += ' mqtt-log-error';
        logEntry.innerHTML = `<span class="mqtt-log-time">[${time}]</span> <span class="mqtt-log-topic">${topic}</span>: <span class="${messageClass}">${message}</span>`;
        mqttLogDiv.prepend(logEntry);
        while (mqttLogDiv.children.length > 50) mqttLogDiv.removeChild(mqttLogDiv.lastChild);
    }

    function updateMqttStatus(connected) {
        isMqttConnected = connected;
        if (connected) {
            mqttStatusIndicator.classList.remove('disconnected');
            mqttStatusIndicator.classList.add('connected');
            mqttStatusText.textContent = "Połączono";
            if (!client._hasConnectedOnce) {
                appendMqttLog("MQTT", "Połączono z brokerem");
                client._hasConnectedOnce = true;
            }
        } else {
            mqttStatusIndicator.classList.remove('connected');
            mqttStatusIndicator.classList.add('disconnected');
            mqttStatusText.textContent = "Rozłączono";
            if (client && client._hasConnectedOnce) {
                appendMqttLog("MQTT", "Rozłączono z brokerem");
                client._hasConnectedOnce = false;
            }
        }
        if (mqttConnectBtn) mqttConnectBtn.disabled = connected;
        if (mqttDisconnectBtn) mqttDisconnectBtn.disabled = !connected;
        if (powerBtn) powerBtn.disabled = !connected;
        if (targetSlider) targetSlider.disabled = !connected;
        if (feedTimeInput) feedTimeInput.disabled = !connected;
        if (pauseTimeInput) pauseTimeInput.disabled = !connected;
        if (maintenanceFeedInput) maintenanceFeedInput.disabled = !connected;
        if (maintenancePauseInput) maintenancePauseInput.disabled = !connected;
        if (blowerManualToggle) blowerManualToggle.disabled = !connected;
        if (blowerWorkPowerSlider) blowerWorkPowerSlider.disabled = !connected;
        if (blowerMaintenanceManualPowerSlider) blowerMaintenanceManualPowerSlider.disabled = !connected;
        if (blowerPurgeManualPowerSlider) blowerPurgeManualPowerSlider.disabled = !connected;
        if (blowerPurgeToggle) blowerPurgeToggle.disabled = !connected;
        if (blowerPurgeOnInput) blowerPurgeOnInput.disabled = !connected;
        if (blowerPurgeOffInput) blowerPurgeOffInput.disabled = !connected;
        if (autoCleanToggle) autoCleanToggle.disabled = !connected;
        if (ashBtn) ashBtn.disabled = !connected;
        if (cleanHoursInput) cleanHoursInput.disabled = !connected;
        if (cleanMinutesInput) cleanMinutesInput.disabled = !connected;
        if (cleanSecondsInput) cleanSecondsInput.disabled = !connected;
        if (updateCleanBtn) updateCleanBtn.disabled = !connected;
        if (resetSessionUptimeBtn) resetSessionUptimeBtn.disabled = !connected;
        if (resetHistoryBtn) resetHistoryBtn.disabled = !connected;
        if (resetPasswordInput) resetPasswordInput.disabled = !connected;
        if (pelletPriceInput) pelletPriceInput.disabled = !connected;
    }

    function connectMQTT() {
        console.log('Attempting MQTT connection...');
        if (client && client.connected) {
            appendMqttLog("MQTT", "Już połączono z brokerem.");
            return;
        }

        const broker = mqttBrokerInput.value;
        const port = mqttPortInput.value;
        const username = mqttUsernameInput.value;
        const password = mqttPasswordInput.value;

        const mqttUrl = `wss://${broker}:${port}/mqtt`;
        appendMqttLog("MQTT", `Próba połączenia z brokerem: ${mqttUrl}`);

        client = mqtt.connect(mqttUrl, {
            clientId: 'web_client_' + Math.random().toString(16).substr(2, 8),
            username: username,
            password: password,
            clean: true,
            keepalive: 60
        });

        client.on('connect', () => {
            updateMqttStatus(true);
            client.subscribe(MQTT_TOPICS.state, (err) => {
                if (!err) appendMqttLog("MQTT", `Subskrybowano: ${MQTT_TOPICS.state}`);
                else appendMqttLog("MQTT ERROR", `Błąd subskrypcji ${MQTT_TOPICS.state}: ${err.message}`, 'error');
            });
        });

        client.on('message', (topic, message) => {
            const msgString = message.toString();
            appendMqttLog(topic, msgString);
            if (topic === MQTT_TOPICS.state) {
                try {
                    const data = JSON.parse(msgString);
                    if (data.timestamp_ms === undefined) data.timestamp_ms = Date.now();
                    updateUI(data);
                } catch (e) {
                    appendMqttLog("JSON PARSE ERROR", `Nie udało się sparsować wiadomości: ${e.message}`, 'error');
                    console.error('MQTT: Failed to parse MQTT message:', e);
                }
            }
        });

        client.on('error', (err) => {
            appendMqttLog("MQTT ERROR", `Błąd połączenia: ${err.message}`, 'error');
            console.error('MQTT: An error occurred:', err);
            updateMqttStatus(false);
            if (client) {
                client.end();
                client = null;
            }
        });

        client.on('close', () => {
            updateMqttStatus(false);
            appendMqttLog("MQTT", "Połączenie zamknięte.");
            client = null;
        });

        client.on('offline', () => {
            appendMqttLog("MQTT", "Klient offline.");
            updateMqttStatus(false);
        });

        client.on('reconnect', () => {
            appendMqttLog("MQTT", "Próba ponownego połączenia...");
            if (mqttStatusText) mqttStatusText.textContent = 'Łączenie...';
            if (mqttStatusIndicator) {
                mqttStatusIndicator.classList.remove('connected');
                mqttStatusIndicator.classList.add('disconnected');
            }
        });
    }

    function disconnectMQTT() {
        if (client) client.end();
        else appendMqttLog("MQTT", "Klient nie jest połączony, nie ma potrzeby rozłączania.");
    }

    function publishMqttMessage(topic, message) {
        if (isMqttConnected && client) {
            client.publish(topic, message.toString(), {}, (err) => {
                if (err) appendMqttLog("PUBLISH ERROR", `Błąd publikacji na ${topic}: ${err.message}`, 'error');
                else appendMqttLog(topic, message.toString(), 'sent');
            });
        } else {
            appendMqttLog("MQTT ERROR", "Nie połączono z brokerem MQTT! Wiadomość nie wysłana.", 'error');
            console.warn("MQTT client not connected. Message not sent.");
        }
    }
    
    function formatTime(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function calculateAverageConsumption(durationMinutes = 60) {
        if (chartData.pellet_consumption.length === 0) return 0.0;
        const now = luxon.DateTime.now();
        const cutoffTime = now.minus({ minutes: durationMinutes }).toMillis();
        const recentData = chartData.pellet_consumption.filter(point => point.x >= cutoffTime);
        return recentData.length ? recentData.reduce((sum, point) => sum + point.y, 0) / recentData.length : 0.0;
    }

    function aggregateDailyConsumption(history) {
        const dailyData = new Map();
        const now = luxon.DateTime.now();
        history.forEach(point => {
            const dateTime = luxon.DateTime.fromMillis(point.x);
            const dateKey = dateTime.toFormat('yyyy-MM-dd');
            const consumptionKg = point.y / 60;
            dailyData.set(dateKey, (dailyData.get(dateKey) || 0) + consumptionKg);
        });
        const labels = [], data = [];
        for (let i = 6; i >= 0; i--) {
            const date = now.minus({ days: i }).toFormat('yyyy-MM-dd');
            labels.push(date);
            data.push(dailyData.get(date) || 0);
        }
        return { labels, data };
    }

    function aggregateMonthlyConsumption(history) {
        const monthlyData = new Map();
        const now = luxon.DateTime.now();
        history.forEach(point => {
            const dateTime = luxon.DateTime.fromMillis(point.x);
            const monthKey = dateTime.toFormat('yyyy-MM');
            const consumptionKg = point.y / 60;
            monthlyData.set(monthKey, (monthlyData.get(monthKey) || 0) + consumptionKg);
        });
        const labels = [], data = [];
        for (let i = 11; i >= 0; i--) {
            const date = now.minus({ months: i }).toFormat('yyyy-MM');
            labels.push(date);
            data.push(monthlyData.get(date) || 0);
        }
        return { labels, data };
    }

    function aggregateYearlyConsumption(history) {
        const yearlyData = new Map();
        const now = luxon.DateTime.now();
        history.forEach(point => {
            const dateTime = luxon.DateTime.fromMillis(point.x);
            const yearKey = dateTime.toFormat('yyyy');
            const consumptionKg = point.y / 60;
            yearlyData.set(yearKey, (yearlyData.get(yearKey) || 0) + consumptionKg);
        });
        const labels = [], data = [];
        for (let i = 4; i >= 0; i--) {
            const date = now.minus({ years: i }).toFormat('yyyy');
            labels.push(date);
            data.push(yearlyData.get(date) || 0);
        }
        return { labels, data };
    }

    function aggregateGlobalConsumption(history) {
        if (history.length === 0) return { labels: ['Total'], data: [0] };
        const totalConsumptionKg = history.reduce((sum, point) => sum + (point.y / 60), 0);
        return { labels: ['Total'], data: [totalConsumptionKg] };
    }

    function initializeCharts() {
        const ctxTemp = document.getElementById('temperature-chart').getContext('2d');
        temperatureChartInstance = new Chart(ctxTemp, {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Woda (°C)', data: chartData.water_temp, borderColor: '#3498db', fill: false, tension: 0.1, hidden: false },
                    { label: 'Pokój (°C)', data: chartData.room_temp, borderColor: '#2ecc71', fill: false, tension: 0.1, hidden: false },
                    { label: 'Palnik (°C)', data: chartData.burner_temp, borderColor: '#e74c3c', fill: false, tension: 0.1, hidden: false },
                    { label: 'Spaliny (°C)', data: chartData.exhaust_temp, borderColor: '#f39c12', fill: false, tension: 0.1, hidden: false }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { type: 'time', time: { unit: 'minute' }, title: { display: true, text: 'Czas' } },
                    y: { beginAtZero: false, title: { display: true, text: 'Temperatura (°C)' } }
                },
                plugins: {
                    zoom: {
                        zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' },
                        pan: { enabled: true, mode: 'x' }
                    }
                }
            }
        });

        const ctxConsumption = document.getElementById('consumption-chart').getContext('2d');
        consumptionChartInstance = new Chart(ctxConsumption, {
            type: 'line',
            data: { datasets: [{ label: 'Zużycie (g/min)', data: chartData.pellet_consumption, borderColor: '#d35400', fill: false, tension: 0.1, hidden: false }] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: { x: { type: 'time', time: { unit: 'minute' }, title: { display: true, text: 'Czas' } }, y: { beginAtZero: true, title: { display: true, text: 'Zużycie (g/min)' } } },
                plugins: { zoom: { zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }, pan: { enabled: true, mode: 'x' } } }
            }
        });

        const ctxDaily = document.getElementById('daily-consumption-chart').getContext('2d');
        dailyConsumptionChartInstance = new Chart(ctxDaily, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Zużycie (kg/dzień)', data: [], backgroundColor: '#d35400', borderColor: '#d35400', borderWidth: 1 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Dzień' } }, y: { beginAtZero: true, title: { display: true, text: 'Zużycie (kg)' } } } }
        });

        const ctxMonthly = document.getElementById('monthly-consumption-chart').getContext('2d');
        monthlyConsumptionChartInstance = new Chart(ctxMonthly, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Zużycie (kg/miesiąc)', data: [], backgroundColor: '#d35400', borderColor: '#d35400', borderWidth: 1 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Miesiąc' } }, y: { beginAtZero: true, title: { display: true, text: 'Zużycie (kg)' } } } }
        });

        const ctxYearly = document.getElementById('yearly-consumption-chart').getContext('2d');
        yearlyConsumptionChartInstance = new Chart(ctxYearly, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Zużycie (kg/rok)', data: [], backgroundColor: '#d35400', borderColor: '#d35400', borderWidth: 1 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Rok' } }, y: { beginAtZero: true, title: { display: true, text: 'Zużycie (kg)' } } } }
        });

        const ctxGlobal = document.getElementById('global-consumption-chart').getContext('2d');
        globalConsumptionChartInstance = new Chart(ctxGlobal, {
            type: 'pie',
            data: { labels: [], datasets: [{ data: [], backgroundColor: ['#d35400'] }] },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' } } }
        });
    }

    function updateUI(data) {
        if (waterTempDisplay) waterTempDisplay.textContent = data.water_temp.toFixed(1) + '°C';
        if (roomTempDisplay) roomTempDisplay.textContent = data.room_temp.toFixed(1) + '°C';
        if (burnerTempDisplay) burnerTempDisplay.textContent = data.burner_temp.toFixed(1) + '°C';
        if (exhaustTempDisplay) exhaustTempDisplay.textContent = data.exhaust_temp.toFixed(1) + '°C';
        if (waterProgressBar) waterProgressBar.style.width = `${(data.water_temp / 85) * 100}%`;
        if (targetTemp) targetTemp.textContent = data.target_temp + '°C';
        if (targetDisplay) targetDisplay.textContent = data.target_temp + '°C';
        if (rssi) rssi.textContent = data.rssi + 'dBm';
        if (ipAddr) ipAddr.textContent = data.ip_addr || 'Brak';

        if (flameIndicator) {
            flameIndicator.classList.toggle('on', data.flame);
            flameIndicator.classList.toggle('off', !data.flame);
        }
        if (igniterIndicator) {
            igniterIndicator.style.display = data.igniter_heating ? 'flex' : 'none';
            igniterIndicator.classList.toggle('ready', data.igniter_ready);
        }
        if (igniterStatusText) igniterStatusText.textContent = data.igniter_status || 'off';
        if (igniterTempDisplay) igniterTempDisplay.textContent = data.igniter_temp.toFixed(1) + '°C';

        if (feederStatusIndicatorMini) feederStatusIndicatorMini.classList.toggle('status-active', data.feeder_active);
        if (blowerStatusIndicatorMini) blowerStatusIndicatorMini.classList.toggle('status-active', data.blower_active);
        if (maintenanceStatus) maintenanceStatus.textContent = data.maintenance_active ? 'AKTYWNY' : 'NIEAKTYWNY';
        if (maintenanceStatusBadge) maintenanceStatusBadge.classList.toggle('maintenance-active', data.maintenance_active);
        if (ashCleaningStatus) ashCleaningStatus.textContent = data.ash_cleaning ? 'TAK' : 'NIE';
        if (cleaningStatusBadge) cleaningStatusBadge.classList.toggle('maintenance-active', data.ash_cleaning);

        if (feederStatus) {
            feederStatus.classList.toggle('on', data.feeder_active);
            feederStatus.classList.toggle('off', !data.feeder_active);
            feederStatus.textContent = `PODAJNIK: ${data.feeder_active ? 'Działa' : 'Przerwa'}`;
        }
        if (cycleProgressBar) cycleProgressBar.style.width = `${(data.feeder_cycle_progress || 0) * 100}%`;
        if (cycleTimer) cycleTimer.textContent = formatTime(data.feeder_cycle_remaining || 0);
        if (pelletAmount) pelletAmount.textContent = (data.pellet_amount || 0).toFixed(2) + ' kg/h';
        if (averagePelletConsumptionDisplay) averagePelletConsumptionDisplay.textContent = (calculateAverageConsumption(60)).toFixed(2) + ' kg/h';

        if (blowerPowerDisplay) blowerPowerDisplay.textContent = data.blower_power + '%';
        if (blowerPowerSlider) blowerPowerSlider.value = data.blower_power;

        if (sessionUptimeDisplay) sessionUptimeDisplay.textContent = formatTime(data.session_uptime || 0);
        if (totalUptimeDisplay) totalUptimeDisplay.textContent = formatTime(data.total_uptime || 0);
        if (burnerHoursDisplay) burnerHoursDisplay.textContent = formatTime(data.burner_hours || 0);
        if (estimatedCostDisplay) estimatedCostDisplay.textContent = (data.estimated_cost || 0).toFixed(2) + ' PLN';
        if (pelletConsumptionInput) pelletConsumptionInput.value = (data.pellet_consumption_rate || 0).toFixed(1);
        if (efficiencyFill) efficiencyFill.style.width = `${(data.efficiency || 0)}%`;
        if (efficiencyLabel) efficiencyLabel.textContent = `${data.efficiency || 0}% Wydajność`;
        if (cleanCountdownDisplay) cleanCountdownDisplay.textContent = formatTime(data.clean_countdown || 0);

        chartData.water_temp.push({ x: data.timestamp_ms, y: data.water_temp });
        chartData.room_temp.push({ x: data.timestamp_ms, y: data.room_temp });
        chartData.burner_temp.push({ x: data.timestamp_ms, y: data.burner_temp });
        chartData.exhaust_temp.push({ x: data.timestamp_ms, y: data.exhaust_temp });
        chartData.pellet_consumption.push({ x: data.timestamp_ms, y: data.pellet_consumption_rate || 0 });

        if (temperatureChartInstance) temperatureChartInstance.update();
        if (consumptionChartInstance) consumptionChartInstance.update();

        const daily = aggregateDailyConsumption(chartData.pellet_consumption);
        if (dailyConsumptionChartInstance) {
            dailyConsumptionChartInstance.data.labels = daily.labels;
            dailyConsumptionChartInstance.data.datasets[0].data = daily.data;
            dailyConsumptionChartInstance.update();
        }

        const monthly = aggregateMonthlyConsumption(chartData.pellet_consumption);
        if (monthlyConsumptionChartInstance) {
            monthlyConsumptionChartInstance.data.labels = monthly.labels;
            monthlyConsumptionChartInstance.data.datasets[0].data = monthly.data;
            monthlyConsumptionChartInstance.update();
        }

        const yearly = aggregateYearlyConsumption(chartData.pellet_consumption);
        if (yearlyConsumptionChartInstance) {
            yearlyConsumptionChartInstance.data.labels = yearly.labels;
            yearlyConsumptionChartInstance.data.datasets[0].data = yearly.data;
            yearlyConsumptionChartInstance.update();
        }

        const global = aggregateGlobalConsumption(chartData.pellet_consumption);
        if (globalConsumptionChartInstance) {
            globalConsumptionChartInstance.data.labels = global.labels;
            globalConsumptionChartInstance.data.datasets[0].data = global.data;
            globalConsumptionChartInstance.update();
        }
    }

    function updateCostCalculation() {
        const pricePerKg = parseFloat(pelletPriceInput.value) || 0;
        const consumptionRate = parseFloat(pelletConsumptionInput.value) || 0;
        const totalCost = (pricePerKg * consumptionRate * (parseInt(totalUptimeDisplay.textContent.split(':')[0]) || 0)).toFixed(2);
        totalCalculatedCost.textContent = `${totalCost} PLN`;
    }

    // Event Listeners
    if (mqttConnectBtn) mqttConnectBtn.addEventListener('click', connectMQTT);
    if (mqttDisconnectBtn) mqttDisconnectBtn.addEventListener('click', disconnectMQTT);
    if (powerBtn) powerBtn.addEventListener('click', () => publishMqttMessage(MQTT_TOPICS.power, JSON.stringify({ command: 'toggle' })));
    if (targetSlider) targetSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        targetDisplay.textContent = `${value}°C`;
        publishMqttMessage(MQTT_TOPICS.targetTemp, JSON.stringify({ target_temp: value }));
    });
    if (feedTimeInput) feedTimeInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ feed_time: parseInt(e.target.value) })));
    if (pauseTimeInput) pauseTimeInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ pause_time: parseInt(e.target.value) })));
    if (maintenanceFeedInput) maintenanceFeedInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ maintenance_feed: parseInt(e.target.value) })));
    if (maintenancePauseInput) maintenancePauseInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ maintenance_pause: parseInt(e.target.value) })));
    if (blowerWorkPowerSlider) blowerWorkPowerSlider.addEventListener('input', (e) => {
        blowerWorkPowerDisplay.textContent = `${e.target.value}%`;
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_work_power: parseInt(e.target.value) }));
    });
    if (blowerMaintenanceManualPowerSlider) blowerMaintenanceManualPowerSlider.addEventListener('input', (e) => {
        blowerMaintenanceManualPowerDisplay.textContent = `${e.target.value}%`;
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_maintenance_power: parseInt(e.target.value) }));
    });
    if (blowerPurgeManualPowerSlider) blowerPurgeManualPowerSlider.addEventListener('input', (e) => {
        blowerPurgeManualPowerDisplay.textContent = `${e.target.value}%`;
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_purge_power: parseInt(e.target.value) }));
    });
    if (blowerManualToggle) blowerManualToggle.addEventListener('change', (e) => {
        blowerManualControlsDiv.style.display = e.target.checked ? 'block' : 'none';
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_manual: e.target.checked }));
    });
    if (blowerPurgeToggle) blowerPurgeToggle.addEventListener('change', (e) => {
        blowerPurgeTimesContainer.style.display = e.target.checked ? 'flex' : 'none';
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_purge: e.target.checked }));
    });
    if (blowerPurgeOnInput) blowerPurgeOnInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_purge_on: parseInt(e.target.value) })));
    if (blowerPurgeOffInput) blowerPurgeOffInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_purge_off: parseInt(e.target.value) })));
    if (ashBtn) ashBtn.addEventListener('click', () => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ command: 'ash_clean' })));
    if (updateCleanBtn) updateCleanBtn.addEventListener('click', () => {
        const hours = parseInt(cleanHoursInput.value) || 0;
        const minutes = parseInt(cleanMinutesInput.value) || 0;
        const seconds = parseInt(cleanSecondsInput.value) || 0;
        const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ clean_countdown: totalSeconds }));
    });
    if (resetSessionUptimeBtn) resetSessionUptimeBtn.addEventListener('click', () => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ command: 'reset_session' })));
    if (resetHistoryBtn) resetHistoryBtn.addEventListener('click', () => {
        if (resetPasswordInput.value === mqttPasswordInput.value) {
            publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ command: 'reset_history' }));
            resetMessageDiv.textContent = 'Dane zresetowane!';
            setTimeout(() => resetMessageDiv.textContent = '', 3000);
        } else {
            resetMessageDiv.textContent = 'Nieprawidłowe hasło!';
            setTimeout(() => resetMessageDiv.textContent = '', 3000);
        }
    });
    if (pelletPriceInput) pelletPriceInput.addEventListener('input', updateCostCalculation);

    temperatureChartToggles.querySelectorAll('.dataset-toggle').forEach(toggle => {
        toggle.addEventListener('click', () => {
            toggle.classList.toggle('active');
            const dataset = toggle.getAttribute('data-chart');
            const index = chartDatasetMap[dataset];
            temperatureChartInstance.data.datasets[index].hidden = !toggle.classList.contains('active');
            temperatureChartInstance.update();
        });
    });

    mainChartSwitcher.querySelectorAll('.chart-switch').forEach(switchBtn => {
        switchBtn.addEventListener('click', () => {
            mainChartSwitcher.querySelectorAll('.chart-switch').forEach(btn => btn.classList.remove('active'));
            switchBtn.classList.add('active');
            const chartType = switchBtn.getAttribute('data-chart-type');
            chartContainerTemp.style.display = chartType === 'temperature' ? 'block' : 'none';
            chartContainerConsumption.style.display = chartType === 'consumption' ? 'block' : 'none';
            chartContainerDailyConsumption.style.display = chartType === 'daily-consumption' ? 'block' : 'none';
            chartContainerMonthlyConsumption.style.display = chartType === 'monthly-consumption' ? 'block' : 'none';
            chartContainerYearlyConsumption.style.display = chartType === 'yearly-consumption' ? 'block' : 'none';
            chartContainerGlobalConsumption.style.display = chartType === 'global-consumption' ? 'block' : 'none';
        });
    });

    historyRangeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            historyRangeButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const range = parseInt(btn.getAttribute('data-range').replace('h', '').replace('d', '')) || 1;
            const duration = btn.getAttribute('data-range').includes('d') ? range * 24 * 60 : range * 60;
            const now = luxon.DateTime.now();
            const cutoff = now.minus({ minutes: duration }).toMillis();
            temperatureChartInstance.data.datasets.forEach(dataset => {
                dataset.data = chartData[dataset.label.split(' ')[0]].filter(point => point.x >= cutoff);
            });
            consumptionChartInstance.data.datasets[0].data = chartData.pellet_consumption.filter(point => point.x >= cutoff);
            temperatureChartInstance.update();
            consumptionChartInstance.update();
        });
    });

    document.getElementById('zoom-in').addEventListener('click', () => temperatureChartInstance.zoomScale('x', 1.1));
    document.getElementById('zoom-out').addEventListener('click', () => temperatureChartInstance.zoomScale('x', 0.9));
    document.getElementById('zoom-reset').addEventListener('click', () => temperatureChartInstance.resetZoom());
    document.getElementById('consumption-zoom-in').addEventListener('click', () => consumptionChartInstance.zoomScale('x', 1.1));
    document.getElementById('consumption-zoom-out').addEventListener('click', () => consumptionChartInstance.zoomScale('x', 0.9));
    document.getElementById('consumption-zoom-reset').addEventListener('click', () => consumptionChartInstance.resetZoom());

    initializeCharts();
    updateCostCalculation();
    connectMQTT(); // Auto-connect on load
});
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOMContentLoaded fired.');

    let client = null;
    let isMqttConnected = false;

    const MQTT_TOPICS = {
        state: "pellet/boiler/state",
        control: "pellet/boiler/control",
        targetTemp: "pellet/boiler/target_temp",
        power: "pellet/boiler/power"
    };

    const mqttBrokerInput = document.getElementById('mqtt-broker');
    const mqttPortInput = document.getElementById('mqtt-port');
    const mqttUsernameInput = document.getElementById('mqtt-username');
    const mqttPasswordInput = document.getElementById('mqtt-password');
    const mqttConnectBtn = document.getElementById('mqtt-connect-btn');
    const mqttDisconnectBtn = document.getElementById('mqtt-disconnect-btn');
    const mqttStatusIndicator = document.getElementById('mqtt-status-indicator');
    const mqttStatusText = document.getElementById('mqtt-status-text');
    const mqttLogDiv = document.getElementById('mqtt-log');

    const powerBtn = document.getElementById('power-btn');
    const targetSlider = document.getElementById('target-slider');
    const targetDisplay = document.getElementById('target-display');
    const targetTemp = document.getElementById('target-temp');

    const waterTempDisplay = document.getElementById('water-temp');
    const roomTempDisplay = document.getElementById('room-temp');
    const burnerTempDisplay = document.getElementById('burner-temp');
    const exhaustTempDisplay = document.getElementById('exhaust-temp');
    const waterProgressBar = document.getElementById('water-progress');
    const flameIndicator = document.getElementById('flame-indicator');
    
    const feederStatusIndicatorMini = document.getElementById('feeder-status-indicator-mini');
    const blowerStatusIndicatorMini = document.getElementById('blower-status-indicator-mini');
    const maintenanceStatus = document.getElementById('maintenance-status');
    const maintenanceStatusBadge = document.getElementById('maintenance-status-badge');
    const ashCleaningStatus = document.getElementById('ash-cleaning-status');
    const cleaningStatusBadge = document.getElementById('cleaning-status-badge');
    const igniterIndicator = document.getElementById('igniter-indicator');
    const igniterStatusText = document.getElementById('igniter-status-text');
    const igniterTempDisplay = document.getElementById('igniter-temp-display');
    const feederStatus = document.getElementById('feeder-status');
    const cycleProgressBar = document.getElementById('cycle-progress-bar');
    const cycleTimer = document.getElementById('cycle-timer');
    const pelletAmount = document.getElementById('pellet-amount');
    const averagePelletConsumptionDisplay = document.getElementById('average-pellet-consumption');

    const feedTimeInput = document.getElementById('feed-time');
    const pauseTimeInput = document.getElementById('pause-time');
    const maintenanceFeedInput = document.getElementById('maintenance-feed');
    const maintenancePauseInput = document.getElementById('maintenance-pause');

    const blowerManualControlsDiv = document.getElementById('blower-manual-controls');
    const blowerManualToggle = document.getElementById('blower-manual-toggle');
    const blowerWorkPowerSlider = document.getElementById('blower-work-power-slider');
    const blowerWorkPowerDisplay = document.getElementById('blower-work-power-display');
    const blowerMaintenanceManualPowerSlider = document.getElementById('blower-maintenance-manual-power-slider');
    const blowerMaintenanceManualPowerDisplay = document.getElementById('blower-maintenance-manual-power-display');
    const blowerPurgeManualPowerSlider = document.getElementById('blower-purge-manual-power-slider');
    const blowerPurgeManualPowerDisplay = document.getElementById('blower-purge-manual-power-display');
    const blowerPowerSlider = document.getElementById('blower-power-slider');
    const blowerPowerDisplay = document.getElementById('blower-power-display');
    const blowerPurgeToggle = document.getElementById('blower-purge-toggle');
    const blowerPurgeTimesContainer = document.getElementById('blower-purge-times');
    const blowerPurgeOnInput = document.getElementById('blower-purge-on');
    const blowerPurgeOffInput = document.getElementById('blower-purge-off');

    const sessionUptimeDisplay = document.getElementById('session-uptime');
    const totalUptimeDisplay = document.getElementById('total-uptime');
    const rssi = document.getElementById('rssi');
    const ipAddr = document.getElementById('ip-addr');

    const burnerHoursDisplay = document.getElementById('burner-hours');
    const estimatedCostDisplay = document.getElementById('estimated-cost');
    const pelletPriceInput = document.getElementById('pellet-price');
    const pelletConsumptionInput = document.getElementById('pellet-consumption');
    const totalCalculatedCost = document.getElementById('total-calculated-cost');
    const efficiencyFill = document.getElementById('efficiency-fill');
    const efficiencyLabel = document.getElementById('efficiency-label');

    const cleanHoursInput = document.getElementById('clean-hours');
    const cleanMinutesInput = document.getElementById('clean-minutes');
    const cleanSecondsInput = document.getElementById('clean-seconds');
    const updateCleanBtn = document.getElementById('update-clean-btn');
    const cleanCountdownDisplay = document.getElementById('clean-countdown-display');

    const ashBtn = document.getElementById('ash-btn');
    const resetSessionUptimeBtn = document.getElementById('reset-session-uptime-btn');
    const resetHistoryBtn = document.getElementById('reset-history-btn');
    const resetPasswordInput = document.getElementById('reset-password');
    const resetMessageDiv = document.getElementById('reset-message');
    
    const temperatureChartToggles = document.getElementById('temperature-chart-toggles');
    const mainChartSwitcher = document.getElementById('main-chart-switcher');
    const chartContainerTemp = document.getElementById('chart-container-temp');
    const chartContainerConsumption = document.getElementById('chart-container-consumption');
    const chartContainerDailyConsumption = document.getElementById('chart-container-daily-consumption');
    const chartContainerMonthlyConsumption = document.getElementById('chart-container-monthly-consumption');
    const chartContainerYearlyConsumption = document.getElementById('chart-container-yearly-consumption');
    const chartContainerGlobalConsumption = document.getElementById('chart-container-global-consumption');
    const historyRangeButtons = document.querySelectorAll('.history-btn');

    let temperatureChartInstance, consumptionChartInstance, dailyConsumptionChartInstance, monthlyConsumptionChartInstance, yearlyConsumptionChartInstance, globalConsumptionChartInstance;

    const chartData = {
        water_temp: [],
        room_temp: [],
        burner_temp: [],
        exhaust_temp: [],
        pellet_consumption: []
    };
    const chartDatasetMap = {
        'water_temp': 0,
        'room_temp': 1,
        'burner_temp': 2,
        'exhaust_temp': 3
    };

    function appendMqttLog(topic, message, type = 'received') {
        const now = new Date();
        const time = now.toTimeString().split(' ')[0].substring(0, 8);
        const logEntry = document.createElement('div');
        logEntry.classList.add('mqtt-log-entry');
        let messageClass = 'mqtt-log-message';
        if (type === 'sent') messageClass += ' mqtt-log-sent';
        else if (type === 'error') messageClass += ' mqtt-log-error';
        logEntry.innerHTML = `<span class="mqtt-log-time">[${time}]</span> <span class="mqtt-log-topic">${topic}</span>: <span class="${messageClass}">${message}</span>`;
        mqttLogDiv.prepend(logEntry);
        while (mqttLogDiv.children.length > 50) mqttLogDiv.removeChild(mqttLogDiv.lastChild);
    }

    function updateMqttStatus(connected) {
        isMqttConnected = connected;
        if (connected) {
            mqttStatusIndicator.classList.remove('disconnected');
            mqttStatusIndicator.classList.add('connected');
            mqttStatusText.textContent = "Połączono";
            if (!client._hasConnectedOnce) {
                appendMqttLog("MQTT", "Połączono z brokerem");
                client._hasConnectedOnce = true;
            }
        } else {
            mqttStatusIndicator.classList.remove('connected');
            mqttStatusIndicator.classList.add('disconnected');
            mqttStatusText.textContent = "Rozłączono";
            if (client && client._hasConnectedOnce) {
                appendMqttLog("MQTT", "Rozłączono z brokerem");
                client._hasConnectedOnce = false;
            }
        }
        if (mqttConnectBtn) mqttConnectBtn.disabled = connected;
        if (mqttDisconnectBtn) mqttDisconnectBtn.disabled = !connected;
        if (powerBtn) powerBtn.disabled = !connected;
        if (targetSlider) targetSlider.disabled = !connected;
        if (feedTimeInput) feedTimeInput.disabled = !connected;
        if (pauseTimeInput) pauseTimeInput.disabled = !connected;
        if (maintenanceFeedInput) maintenanceFeedInput.disabled = !connected;
        if (maintenancePauseInput) maintenancePauseInput.disabled = !connected;
        if (blowerManualToggle) blowerManualToggle.disabled = !connected;
        if (blowerWorkPowerSlider) blowerWorkPowerSlider.disabled = !connected;
        if (blowerMaintenanceManualPowerSlider) blowerMaintenanceManualPowerSlider.disabled = !connected;
        if (blowerPurgeManualPowerSlider) blowerPurgeManualPowerSlider.disabled = !connected;
        if (blowerPurgeToggle) blowerPurgeToggle.disabled = !connected;
        if (blowerPurgeOnInput) blowerPurgeOnInput.disabled = !connected;
        if (blowerPurgeOffInput) blowerPurgeOffInput.disabled = !connected;
        if (autoCleanToggle) autoCleanToggle.disabled = !connected;
        if (ashBtn) ashBtn.disabled = !connected;
        if (cleanHoursInput) cleanHoursInput.disabled = !connected;
        if (cleanMinutesInput) cleanMinutesInput.disabled = !connected;
        if (cleanSecondsInput) cleanSecondsInput.disabled = !connected;
        if (updateCleanBtn) updateCleanBtn.disabled = !connected;
        if (resetSessionUptimeBtn) resetSessionUptimeBtn.disabled = !connected;
        if (resetHistoryBtn) resetHistoryBtn.disabled = !connected;
        if (resetPasswordInput) resetPasswordInput.disabled = !connected;
        if (pelletPriceInput) pelletPriceInput.disabled = !connected;
    }

    function connectMQTT() {
        console.log('Attempting MQTT connection...');
        if (client && client.connected) {
            appendMqttLog("MQTT", "Już połączono z brokerem.");
            return;
        }

        const broker = mqttBrokerInput.value;
        const port = mqttPortInput.value;
        const username = mqttUsernameInput.value;
        const password = mqttPasswordInput.value;

        const mqttUrl = `wss://${broker}:${port}/mqtt`;
        appendMqttLog("MQTT", `Próba połączenia z brokerem: ${mqttUrl}`);

        client = mqtt.connect(mqttUrl, {
            clientId: 'web_client_' + Math.random().toString(16).substr(2, 8),
            username: username,
            password: password,
            clean: true,
            keepalive: 60
        });

        client.on('connect', () => {
            updateMqttStatus(true);
            client.subscribe(MQTT_TOPICS.state, (err) => {
                if (!err) appendMqttLog("MQTT", `Subskrybowano: ${MQTT_TOPICS.state}`);
                else appendMqttLog("MQTT ERROR", `Błąd subskrypcji ${MQTT_TOPICS.state}: ${err.message}`, 'error');
            });
        });

        client.on('message', (topic, message) => {
            const msgString = message.toString();
            appendMqttLog(topic, msgString);
            if (topic === MQTT_TOPICS.state) {
                try {
                    const data = JSON.parse(msgString);
                    if (data.timestamp_ms === undefined) data.timestamp_ms = Date.now();
                    updateUI(data);
                } catch (e) {
                    appendMqttLog("JSON PARSE ERROR", `Nie udało się sparsować wiadomości: ${e.message}`, 'error');
                    console.error('MQTT: Failed to parse MQTT message:', e);
                }
            }
        });

        client.on('error', (err) => {
            appendMqttLog("MQTT ERROR", `Błąd połączenia: ${err.message}`, 'error');
            console.error('MQTT: An error occurred:', err);
            updateMqttStatus(false);
            if (client) {
                client.end();
                client = null;
            }
        });

        client.on('close', () => {
            updateMqttStatus(false);
            appendMqttLog("MQTT", "Połączenie zamknięte.");
            client = null;
        });

        client.on('offline', () => {
            appendMqttLog("MQTT", "Klient offline.");
            updateMqttStatus(false);
        });

        client.on('reconnect', () => {
            appendMqttLog("MQTT", "Próba ponownego połączenia...");
            if (mqttStatusText) mqttStatusText.textContent = 'Łączenie...';
            if (mqttStatusIndicator) {
                mqttStatusIndicator.classList.remove('connected');
                mqttStatusIndicator.classList.add('disconnected');
            }
        });
    }

    function disconnectMQTT() {
        if (client) client.end();
        else appendMqttLog("MQTT", "Klient nie jest połączony, nie ma potrzeby rozłączania.");
    }

    function publishMqttMessage(topic, message) {
        if (isMqttConnected && client) {
            client.publish(topic, message.toString(), {}, (err) => {
                if (err) appendMqttLog("PUBLISH ERROR", `Błąd publikacji na ${topic}: ${err.message}`, 'error');
                else appendMqttLog(topic, message.toString(), 'sent');
            });
        } else {
            appendMqttLog("MQTT ERROR", "Nie połączono z brokerem MQTT! Wiadomość nie wysłana.", 'error');
            console.warn("MQTT client not connected. Message not sent.");
        }
    }
    
    function formatTime(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function calculateAverageConsumption(durationMinutes = 60) {
        if (chartData.pellet_consumption.length === 0) return 0.0;
        const now = luxon.DateTime.now();
        const cutoffTime = now.minus({ minutes: durationMinutes }).toMillis();
        const recentData = chartData.pellet_consumption.filter(point => point.x >= cutoffTime);
        return recentData.length ? recentData.reduce((sum, point) => sum + point.y, 0) / recentData.length : 0.0;
    }

    function aggregateDailyConsumption(history) {
        const dailyData = new Map();
        const now = luxon.DateTime.now();
        history.forEach(point => {
            const dateTime = luxon.DateTime.fromMillis(point.x);
            const dateKey = dateTime.toFormat('yyyy-MM-dd');
            const consumptionKg = point.y / 60;
            dailyData.set(dateKey, (dailyData.get(dateKey) || 0) + consumptionKg);
        });
        const labels = [], data = [];
        for (let i = 6; i >= 0; i--) {
            const date = now.minus({ days: i }).toFormat('yyyy-MM-dd');
            labels.push(date);
            data.push(dailyData.get(date) || 0);
        }
        return { labels, data };
    }

    function aggregateMonthlyConsumption(history) {
        const monthlyData = new Map();
        const now = luxon.DateTime.now();
        history.forEach(point => {
            const dateTime = luxon.DateTime.fromMillis(point.x);
            const monthKey = dateTime.toFormat('yyyy-MM');
            const consumptionKg = point.y / 60;
            monthlyData.set(monthKey, (monthlyData.get(monthKey) || 0) + consumptionKg);
        });
        const labels = [], data = [];
        for (let i = 11; i >= 0; i--) {
            const date = now.minus({ months: i }).toFormat('yyyy-MM');
            labels.push(date);
            data.push(monthlyData.get(date) || 0);
        }
        return { labels, data };
    }

    function aggregateYearlyConsumption(history) {
        const yearlyData = new Map();
        const now = luxon.DateTime.now();
        history.forEach(point => {
            const dateTime = luxon.DateTime.fromMillis(point.x);
            const yearKey = dateTime.toFormat('yyyy');
            const consumptionKg = point.y / 60;
            yearlyData.set(yearKey, (yearlyData.get(yearKey) || 0) + consumptionKg);
        });
        const labels = [], data = [];
        for (let i = 4; i >= 0; i--) {
            const date = now.minus({ years: i }).toFormat('yyyy');
            labels.push(date);
            data.push(yearlyData.get(date) || 0);
        }
        return { labels, data };
    }

    function aggregateGlobalConsumption(history) {
        if (history.length === 0) return { labels: ['Total'], data: [0] };
        const totalConsumptionKg = history.reduce((sum, point) => sum + (point.y / 60), 0);
        return { labels: ['Total'], data: [totalConsumptionKg] };
    }

    function initializeCharts() {
        const ctxTemp = document.getElementById('temperature-chart').getContext('2d');
        temperatureChartInstance = new Chart(ctxTemp, {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Woda (°C)', data: chartData.water_temp, borderColor: '#3498db', fill: false, tension: 0.1, hidden: false },
                    { label: 'Pokój (°C)', data: chartData.room_temp, borderColor: '#2ecc71', fill: false, tension: 0.1, hidden: false },
                    { label: 'Palnik (°C)', data: chartData.burner_temp, borderColor: '#e74c3c', fill: false, tension: 0.1, hidden: false },
                    { label: 'Spaliny (°C)', data: chartData.exhaust_temp, borderColor: '#f39c12', fill: false, tension: 0.1, hidden: false }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { type: 'time', time: { unit: 'minute' }, title: { display: true, text: 'Czas' } },
                    y: { beginAtZero: false, title: { display: true, text: 'Temperatura (°C)' } }
                },
                plugins: {
                    zoom: {
                        zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' },
                        pan: { enabled: true, mode: 'x' }
                    }
                }
            }
        });

        const ctxConsumption = document.getElementById('consumption-chart').getContext('2d');
        consumptionChartInstance = new Chart(ctxConsumption, {
            type: 'line',
            data: { datasets: [{ label: 'Zużycie (g/min)', data: chartData.pellet_consumption, borderColor: '#d35400', fill: false, tension: 0.1, hidden: false }] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: { x: { type: 'time', time: { unit: 'minute' }, title: { display: true, text: 'Czas' } }, y: { beginAtZero: true, title: { display: true, text: 'Zużycie (g/min)' } } },
                plugins: { zoom: { zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }, pan: { enabled: true, mode: 'x' } } }
            }
        });

        const ctxDaily = document.getElementById('daily-consumption-chart').getContext('2d');
        dailyConsumptionChartInstance = new Chart(ctxDaily, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Zużycie (kg/dzień)', data: [], backgroundColor: '#d35400', borderColor: '#d35400', borderWidth: 1 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Dzień' } }, y: { beginAtZero: true, title: { display: true, text: 'Zużycie (kg)' } } } }
        });

        const ctxMonthly = document.getElementById('monthly-consumption-chart').getContext('2d');
        monthlyConsumptionChartInstance = new Chart(ctxMonthly, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Zużycie (kg/miesiąc)', data: [], backgroundColor: '#d35400', borderColor: '#d35400', borderWidth: 1 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Miesiąc' } }, y: { beginAtZero: true, title: { display: true, text: 'Zużycie (kg)' } } } }
        });

        const ctxYearly = document.getElementById('yearly-consumption-chart').getContext('2d');
        yearlyConsumptionChartInstance = new Chart(ctxYearly, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Zużycie (kg/rok)', data: [], backgroundColor: '#d35400', borderColor: '#d35400', borderWidth: 1 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Rok' } }, y: { beginAtZero: true, title: { display: true, text: 'Zużycie (kg)' } } } }
        });

        const ctxGlobal = document.getElementById('global-consumption-chart').getContext('2d');
        globalConsumptionChartInstance = new Chart(ctxGlobal, {
            type: 'pie',
            data: { labels: [], datasets: [{ data: [], backgroundColor: ['#d35400'] }] },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' } } }
        });
    }

    function updateUI(data) {
        if (waterTempDisplay) waterTempDisplay.textContent = data.water_temp.toFixed(1) + '°C';
        if (roomTempDisplay) roomTempDisplay.textContent = data.room_temp.toFixed(1) + '°C';
        if (burnerTempDisplay) burnerTempDisplay.textContent = data.burner_temp.toFixed(1) + '°C';
        if (exhaustTempDisplay) exhaustTempDisplay.textContent = data.exhaust_temp.toFixed(1) + '°C';
        if (waterProgressBar) waterProgressBar.style.width = `${(data.water_temp / 85) * 100}%`;
        if (targetTemp) targetTemp.textContent = data.target_temp + '°C';
        if (targetDisplay) targetDisplay.textContent = data.target_temp + '°C';
        if (rssi) rssi.textContent = data.rssi + 'dBm';
        if (ipAddr) ipAddr.textContent = data.ip_addr || 'Brak';

        if (flameIndicator) {
            flameIndicator.classList.toggle('on', data.flame);
            flameIndicator.classList.toggle('off', !data.flame);
        }
        if (igniterIndicator) {
            igniterIndicator.style.display = data.igniter_heating ? 'flex' : 'none';
            igniterIndicator.classList.toggle('ready', data.igniter_ready);
        }
        if (igniterStatusText) igniterStatusText.textContent = data.igniter_status || 'off';
        if (igniterTempDisplay) igniterTempDisplay.textContent = data.igniter_temp.toFixed(1) + '°C';

        if (feederStatusIndicatorMini) feederStatusIndicatorMini.classList.toggle('status-active', data.feeder_active);
        if (blowerStatusIndicatorMini) blowerStatusIndicatorMini.classList.toggle('status-active', data.blower_active);
        if (maintenanceStatus) maintenanceStatus.textContent = data.maintenance_active ? 'AKTYWNY' : 'NIEAKTYWNY';
        if (maintenanceStatusBadge) maintenanceStatusBadge.classList.toggle('maintenance-active', data.maintenance_active);
        if (ashCleaningStatus) ashCleaningStatus.textContent = data.ash_cleaning ? 'TAK' : 'NIE';
        if (cleaningStatusBadge) cleaningStatusBadge.classList.toggle('maintenance-active', data.ash_cleaning);

        if (feederStatus) {
            feederStatus.classList.toggle('on', data.feeder_active);
            feederStatus.classList.toggle('off', !data.feeder_active);
            feederStatus.textContent = `PODAJNIK: ${data.feeder_active ? 'Działa' : 'Przerwa'}`;
        }
        if (cycleProgressBar) cycleProgressBar.style.width = `${(data.feeder_cycle_progress || 0) * 100}%`;
        if (cycleTimer) cycleTimer.textContent = formatTime(data.feeder_cycle_remaining || 0);
        if (pelletAmount) pelletAmount.textContent = (data.pellet_amount || 0).toFixed(2) + ' kg/h';
        if (averagePelletConsumptionDisplay) averagePelletConsumptionDisplay.textContent = (calculateAverageConsumption(60)).toFixed(2) + ' kg/h';

        if (blowerPowerDisplay) blowerPowerDisplay.textContent = data.blower_power + '%';
        if (blowerPowerSlider) blowerPowerSlider.value = data.blower_power;

        if (sessionUptimeDisplay) sessionUptimeDisplay.textContent = formatTime(data.session_uptime || 0);
        if (totalUptimeDisplay) totalUptimeDisplay.textContent = formatTime(data.total_uptime || 0);
        if (burnerHoursDisplay) burnerHoursDisplay.textContent = formatTime(data.burner_hours || 0);
        if (estimatedCostDisplay) estimatedCostDisplay.textContent = (data.estimated_cost || 0).toFixed(2) + ' PLN';
        if (pelletConsumptionInput) pelletConsumptionInput.value = (data.pellet_consumption_rate || 0).toFixed(1);
        if (efficiencyFill) efficiencyFill.style.width = `${(data.efficiency || 0)}%`;
        if (efficiencyLabel) efficiencyLabel.textContent = `${data.efficiency || 0}% Wydajność`;
        if (cleanCountdownDisplay) cleanCountdownDisplay.textContent = formatTime(data.clean_countdown || 0);

        chartData.water_temp.push({ x: data.timestamp_ms, y: data.water_temp });
        chartData.room_temp.push({ x: data.timestamp_ms, y: data.room_temp });
        chartData.burner_temp.push({ x: data.timestamp_ms, y: data.burner_temp });
        chartData.exhaust_temp.push({ x: data.timestamp_ms, y: data.exhaust_temp });
        chartData.pellet_consumption.push({ x: data.timestamp_ms, y: data.pellet_consumption_rate || 0 });

        if (temperatureChartInstance) temperatureChartInstance.update();
        if (consumptionChartInstance) consumptionChartInstance.update();

        const daily = aggregateDailyConsumption(chartData.pellet_consumption);
        if (dailyConsumptionChartInstance) {
            dailyConsumptionChartInstance.data.labels = daily.labels;
            dailyConsumptionChartInstance.data.datasets[0].data = daily.data;
            dailyConsumptionChartInstance.update();
        }

        const monthly = aggregateMonthlyConsumption(chartData.pellet_consumption);
        if (monthlyConsumptionChartInstance) {
            monthlyConsumptionChartInstance.data.labels = monthly.labels;
            monthlyConsumptionChartInstance.data.datasets[0].data = monthly.data;
            monthlyConsumptionChartInstance.update();
        }

        const yearly = aggregateYearlyConsumption(chartData.pellet_consumption);
        if (yearlyConsumptionChartInstance) {
            yearlyConsumptionChartInstance.data.labels = yearly.labels;
            yearlyConsumptionChartInstance.data.datasets[0].data = yearly.data;
            yearlyConsumptionChartInstance.update();
        }

        const global = aggregateGlobalConsumption(chartData.pellet_consumption);
        if (globalConsumptionChartInstance) {
            globalConsumptionChartInstance.data.labels = global.labels;
            globalConsumptionChartInstance.data.datasets[0].data = global.data;
            globalConsumptionChartInstance.update();
        }
    }

    function updateCostCalculation() {
        const pricePerKg = parseFloat(pelletPriceInput.value) || 0;
        const consumptionRate = parseFloat(pelletConsumptionInput.value) || 0;
        const totalCost = (pricePerKg * consumptionRate * (parseInt(totalUptimeDisplay.textContent.split(':')[0]) || 0)).toFixed(2);
        totalCalculatedCost.textContent = `${totalCost} PLN`;
    }

    // Event Listeners
    if (mqttConnectBtn) mqttConnectBtn.addEventListener('click', connectMQTT);
    if (mqttDisconnectBtn) mqttDisconnectBtn.addEventListener('click', disconnectMQTT);
    if (powerBtn) powerBtn.addEventListener('click', () => publishMqttMessage(MQTT_TOPICS.power, JSON.stringify({ command: 'toggle' })));
    if (targetSlider) targetSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        targetDisplay.textContent = `${value}°C`;
        publishMqttMessage(MQTT_TOPICS.targetTemp, JSON.stringify({ target_temp: value }));
    });
    if (feedTimeInput) feedTimeInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ feed_time: parseInt(e.target.value) })));
    if (pauseTimeInput) pauseTimeInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ pause_time: parseInt(e.target.value) })));
    if (maintenanceFeedInput) maintenanceFeedInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ maintenance_feed: parseInt(e.target.value) })));
    if (maintenancePauseInput) maintenancePauseInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ maintenance_pause: parseInt(e.target.value) })));
    if (blowerWorkPowerSlider) blowerWorkPowerSlider.addEventListener('input', (e) => {
        blowerWorkPowerDisplay.textContent = `${e.target.value}%`;
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_work_power: parseInt(e.target.value) }));
    });
    if (blowerMaintenanceManualPowerSlider) blowerMaintenanceManualPowerSlider.addEventListener('input', (e) => {
        blowerMaintenanceManualPowerDisplay.textContent = `${e.target.value}%`;
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_maintenance_power: parseInt(e.target.value) }));
    });
    if (blowerPurgeManualPowerSlider) blowerPurgeManualPowerSlider.addEventListener('input', (e) => {
        blowerPurgeManualPowerDisplay.textContent = `${e.target.value}%`;
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_purge_power: parseInt(e.target.value) }));
    });
    if (blowerManualToggle) blowerManualToggle.addEventListener('change', (e) => {
        blowerManualControlsDiv.style.display = e.target.checked ? 'block' : 'none';
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_manual: e.target.checked }));
    });
    if (blowerPurgeToggle) blowerPurgeToggle.addEventListener('change', (e) => {
        blowerPurgeTimesContainer.style.display = e.target.checked ? 'flex' : 'none';
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_purge: e.target.checked }));
    });
    if (blowerPurgeOnInput) blowerPurgeOnInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_purge_on: parseInt(e.target.value) })));
    if (blowerPurgeOffInput) blowerPurgeOffInput.addEventListener('change', (e) => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ blower_purge_off: parseInt(e.target.value) })));
    if (ashBtn) ashBtn.addEventListener('click', () => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ command: 'ash_clean' })));
    if (updateCleanBtn) updateCleanBtn.addEventListener('click', () => {
        const hours = parseInt(cleanHoursInput.value) || 0;
        const minutes = parseInt(cleanMinutesInput.value) || 0;
        const seconds = parseInt(cleanSecondsInput.value) || 0;
        const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
        publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ clean_countdown: totalSeconds }));
    });
    if (resetSessionUptimeBtn) resetSessionUptimeBtn.addEventListener('click', () => publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ command: 'reset_session' })));
    if (resetHistoryBtn) resetHistoryBtn.addEventListener('click', () => {
        if (resetPasswordInput.value === mqttPasswordInput.value) {
            publishMqttMessage(MQTT_TOPICS.control, JSON.stringify({ command: 'reset_history' }));
            resetMessageDiv.textContent = 'Dane zresetowane!';
            setTimeout(() => resetMessageDiv.textContent = '', 3000);
        } else {
            resetMessageDiv.textContent = 'Nieprawidłowe hasło!';
            setTimeout(() => resetMessageDiv.textContent = '', 3000);
        }
    });
    if (pelletPriceInput) pelletPriceInput.addEventListener('input', updateCostCalculation);

    temperatureChartToggles.querySelectorAll('.dataset-toggle').forEach(toggle => {
        toggle.addEventListener('click', () => {
            toggle.classList.toggle('active');
            const dataset = toggle.getAttribute('data-chart');
            const index = chartDatasetMap[dataset];
            temperatureChartInstance.data.datasets[index].hidden = !toggle.classList.contains('active');
            temperatureChartInstance.update();
        });
    });

    mainChartSwitcher.querySelectorAll('.chart-switch').forEach(switchBtn => {
        switchBtn.addEventListener('click', () => {
            mainChartSwitcher.querySelectorAll('.chart-switch').forEach(btn => btn.classList.remove('active'));
            switchBtn.classList.add('active');
            const chartType = switchBtn.getAttribute('data-chart-type');
            chartContainerTemp.style.display = chartType === 'temperature' ? 'block' : 'none';
            chartContainerConsumption.style.display = chartType === 'consumption' ? 'block' : 'none';
            chartContainerDailyConsumption.style.display = chartType === 'daily-consumption' ? 'block' : 'none';
            chartContainerMonthlyConsumption.style.display = chartType === 'monthly-consumption' ? 'block' : 'none';
            chartContainerYearlyConsumption.style.display = chartType === 'yearly-consumption' ? 'block' : 'none';
            chartContainerGlobalConsumption.style.display = chartType === 'global-consumption' ? 'block' : 'none';
        });
    });

    historyRangeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            historyRangeButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const range = parseInt(btn.getAttribute('data-range').replace('h', '').replace('d', '')) || 1;
            const duration = btn.getAttribute('data-range').includes('d') ? range * 24 * 60 : range * 60;
            const now = luxon.DateTime.now();
            const cutoff = now.minus({ minutes: duration }).toMillis();
            temperatureChartInstance.data.datasets.forEach(dataset => {
                dataset.data = chartData[dataset.label.split(' ')[0]].filter(point => point.x >= cutoff);
            });
            consumptionChartInstance.data.datasets[0].data = chartData.pellet_consumption.filter(point => point.x >= cutoff);
            temperatureChartInstance.update();
            consumptionChartInstance.update();
        });
    });

    document.getElementById('zoom-in').addEventListener('click', () => temperatureChartInstance.zoomScale('x', 1.1));
    document.getElementById('zoom-out').addEventListener('click', () => temperatureChartInstance.zoomScale('x', 0.9));
    document.getElementById('zoom-reset').addEventListener('click', () => temperatureChartInstance.resetZoom());
    document.getElementById('consumption-zoom-in').addEventListener('click', () => consumptionChartInstance.zoomScale('x', 1.1));
    document.getElementById('consumption-zoom-out').addEventListener('click', () => consumptionChartInstance.zoomScale('x', 0.9));
    document.getElementById('consumption-zoom-reset').addEventListener('click', () => consumptionChartInstance.resetZoom());

    initializeCharts();
    updateCostCalculation();
    connectMQTT(); // Auto-connect on load
});
