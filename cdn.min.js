document.addEventListener('DOMContentLoaded', () => {
    console.log('DOMContentLoaded fired.');

    // Stałe i konfiguracja
    const MQTT_TOPICS = {
        state: "pellet/boiler/state",
        control: "pellet/boiler/control",
        targetTemp: "pellet/boiler/target_temp",
        power: "pellet/boiler/power"
    };

    // Elementy interfejsu
    const mqttBrokerInput = document.getElementById('mqtt-broker');
    const mqttPortInput = document.getElementById('mqtt-port');
    const mqttUsernameInput = document.getElementById('mqtt-username');
    const mqttPasswordInput = document.getElementById('mqtt-password');
    const mqttConnectBtn = document.getElementById('mqtt-connect-btn');
    const mqttDisconnectBtn = document.getElementById('mqtt-disconnect-btn');
    const mqttStatusIndicator = document.getElementById('mqtt-status-indicator');
    const mqttStatusText = document.getElementById('mqtt-status-text');
    const mqttLogDiv = document.getElementById('mqtt-log');
    const powerBtn = document.getElementById('power-btn');
    const targetSlider = document.getElementById('target-slider');
    const targetDisplay = document.getElementById('target-display');
    const targetTemp = document.getElementById('target-temp');
    const waterTempDisplay = document.getElementById('water-temp');
    const roomTempDisplay = document.getElementById('room-temp');
    const burnerTempDisplay = document.getElementById('burner-temp');
    const exhaustTempDisplay = document.getElementById('exhaust-temp');
    const waterProgressBar = document.getElementById('water-progress');
    const flameIndicator = document.getElementById('flame-indicator');
    const feederStatusIndicatorMini = document.getElementById('feeder-status-indicator-mini');
    const blowerStatusIndicatorMini = document.getElementById('blower-status-indicator-mini');
    const maintenanceStatus = document.getElementById('maintenance-status');
    const maintenanceStatusBadge = document.getElementById('maintenance-status-badge');
    const ashCleaningStatus = document.getElementById('ash-cleaning-status');
    const cleaningStatusBadge = document.getElementById('cleaning-status-badge');
    const igniterIndicator = document.getElementById('igniter-indicator');
    const igniterStatusText = document.getElementById('igniter-status-text');
    const igniterTempDisplay = document.getElementById('igniter-temp-display');
    const feederStatus = document.getElementById('feeder-status');
    const cycleProgressBar = document.getElementById('cycle-progress-bar');
    const cycleTimer = document.getElementById('cycle-timer');
    const pelletAmount = document.getElementById('pellet-amount');
    const averagePelletConsumptionDisplay = document.getElementById('average-pellet-consumption');
    const feedTimeInput = document.getElementById('feed-time');
    const pauseTimeInput = document.getElementById('pause-time');
    const maintenanceFeedInput = document.getElementById('maintenance-feed');
    const maintenancePauseInput = document.getElementById('maintenance-pause');
    const blowerManualControlsDiv = document.getElementById('blower-manual-controls');
    const blowerManualToggle = document.getElementById('blower-manual-toggle');
    const blowerWorkPowerSlider = document.getElementById('blower-work-power-slider');
    const blowerWorkPowerDisplay = document.getElementById('blower-work-power-display');
    const blowerMaintenanceManualPowerSlider = document.getElementById('blower-maintenance-manual-power-slider');
    const blowerMaintenanceManualPowerDisplay = document.getElementById('blower-maintenance-manual-power-display');
    const blowerPurgeManualPowerSlider = document.getElementById('blower-purge-manual-power-slider');
    const blowerPurgeManualPowerDisplay = document.getElementById('blower-purge-manual-power-display');
    const blowerPowerSlider = document.getElementById('blower-power-slider');
    const blowerPowerDisplay = document.getElementById('blower-power-display');
    const blowerPurgeToggle = document.getElementById('blower-purge-toggle');
    const blowerPurgeTimesContainer = document.getElementById('blower-purge-times');
    const blowerPurgeOnInput = document.getElementById('blower-purge-on');
    const blowerPurgeOffInput = document.getElementById('blower-purge-off');
    const sessionUptimeDisplay = document.getElementById('session-uptime');
    const totalUptimeDisplay = document.getElementById('total-uptime');
    const rssiDisplay = document.getElementById('rssi');
    const ipAddrDisplay = document.getElementById('ip-addr');
    const burnerHoursDisplay = document.getElementById('burner-hours');
    const estimatedCostDisplay = document.getElementById('estimated-cost');
    const pelletPriceInput = document.getElementById('pellet-price');
    const pelletConsumptionInput = document.getElementById('pellet-consumption');
    const totalCalculatedCost = document.getElementById('total-calculated-cost');
    const efficiencyFill = document.getElementById('efficiency-fill');
    const efficiencyLabel = document.getElementById('efficiency-label');
    const cleanHoursInput = document.getElementById('clean-hours');
    const cleanMinutesInput = document.getElementById('clean-minutes');
    const cleanSecondsInput = document.getElementById('clean-seconds');
    const updateCleanBtn = document.getElementById('update-clean-btn');
    const cleanCountdownDisplay = document.getElementById('clean-countdown-display');
    const ashBtn = document.getElementById('ash-btn');
    const resetSessionUptimeBtn = document.getElementById('reset-session-uptime-btn');
    const resetHistoryBtn = document.getElementById('reset-history-btn');
    const resetPasswordInput = document.getElementById('reset-password');
    const resetMessageDiv = document.getElementById('reset-message');
    const temperatureChartToggles = document.getElementById('temperature-chart-toggles');
    const mainChartSwitcher = document.getElementById('main-chart-switcher');
    const chartContainerTemp = document.getElementById('chart-container-temp');
    const chartContainerConsumption = document.getElementById('chart-container-consumption');
    const historyRangeButtons = document.querySelectorAll('.history-btn');

    // Zmienne globalne
    let client = null;
    let isMqttConnected = false;
    const chartData = {
        water_temp: [],
        room_temp: [],
        burner_temp: [],
        exhaust_temp: [],
        pellet_consumption: []
    };
    const chartDatasetMap = {
        'water_temp': 0,
        'room_temp': 1,
        'burner_temp': 2,
        'exhaust_temp': 3
    };
    let temperatureChartInstance, consumptionChartInstance;

    // Funkcje pomocnicze
    function appendMqttLog(topic, message, type = 'received') {
        const now = new Date();
        const time = now.toTimeString().split(' ')[0].substring(0, 8);
        const logEntry = document.createElement('div');
        logEntry.classList.add('mqtt-log-entry');
        
        let messageClass = 'mqtt-log-message';
        if (type === 'sent') messageClass += ' mqtt-log-sent';
        else if (type === 'error') messageClass += ' mqtt-log-error';
        
        logEntry.innerHTML = `
            <span class="mqtt-log-time">[${time}]</span> 
            <span class="mqtt-log-topic">${topic}</span>: 
            <span class="${messageClass}">${message}</span>
        `;
        mqttLogDiv.prepend(logEntry);
        
        while (mqttLogDiv.children.length > 50) {
            mqttLogDiv.removeChild(mqttLogDiv.lastChild);
        }
    }

    function updateMqttStatus(connected) {
        isMqttConnected = connected;
        mqttStatusIndicator.classList.toggle('connected', connected);
        mqttStatusIndicator.classList.toggle('disconnected', !connected);
        mqttStatusText.textContent = connected ? "Połączono" : "Rozłączono";
        mqttConnectBtn.disabled = connected;
        mqttDisconnectBtn.disabled = !connected;
        
        // Aktualizacja stanu przycisków
        const controls = [
            powerBtn, targetSlider, feedTimeInput, pauseTimeInput, 
            maintenanceFeedInput, maintenancePauseInput, blowerManualToggle,
            blowerWorkPowerSlider, blowerMaintenanceManualPowerSlider,
            blowerPurgeManualPowerSlider, blowerPurgeToggle,
            blowerPurgeOnInput, blowerPurgeOffInput, ashBtn,
            cleanHoursInput, cleanMinutesInput, cleanSecondsInput,
            updateCleanBtn, resetSessionUptimeBtn, resetHistoryBtn,
            resetPasswordInput, pelletPriceInput
        ];
        
        controls.forEach(control => {
            if (control) control.disabled = !connected;
        });
    }

    function formatTime(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function calculateAverageConsumption(durationMinutes = 60) {
        if (chartData.pellet_consumption.length === 0) return 0.0;
        
        const now = Date.now();
        const cutoffTime = now - (durationMinutes * 60 * 1000);
        const recentData = chartData.pellet_consumption.filter(point => point.x >= cutoffTime);
        
        return recentData.length ? 
            recentData.reduce((sum, point) => sum + point.y, 0) / recentData.length : 
            0.0;
    }

    // Połączenie MQTT
    function connectMQTT() {
        if (client && client.connected) {
            appendMqttLog("MQTT", "Już połączono z brokerem.");
            return;
        }

        const broker = mqttBrokerInput.value;
        const port = mqttPortInput.value;
        const username = mqttUsernameInput.value;
        const password = mqttPasswordInput.value;
        const mqttUrl = `wss://${broker}:${port}/mqtt`;

        appendMqttLog("MQTT", `Próba połączenia z brokerem: ${mqttUrl}`);
        client = mqtt.connect(mqttUrl, {
            clientId: 'web_client_' + Math.random().toString(16).substr(2, 8),
            username: username,
            password: password,
            clean: true,
            keepalive: 60
        });

        client.on('connect', () => {
            updateMqttStatus(true);
            client.subscribe(MQTT_TOPICS.state, (err) => {
                if (!err) {
                    appendMqttLog("MQTT", `Subskrybowano: ${MQTT_TOPICS.state}`);
                } else {
                    appendMqttLog("MQTT ERROR", `Błąd subskrypcji: ${err.message}`, 'error');
                }
            });
        });

        client.on('message', (topic, message) => {
            const msgString = message.toString();
            appendMqttLog(topic, msgString);
            
            if (topic === MQTT_TOPICS.state) {
                try {
                    const data = JSON.parse(msgString);
                    if (!data.timestamp_ms) data.timestamp_ms = Date.now();
                    updateUI(data);
                } catch (e) {
                    appendMqttLog("JSON PARSE ERROR", `Błąd parsowania: ${e.message}`, 'error');
                    console.error('MQTT: Failed to parse message:', e);
                }
            }
        });

        client.on('error', (err) => {
            appendMqttLog("MQTT ERROR", `Błąd połączenia: ${err.message}`, 'error');
            updateMqttStatus(false);
            if (client) client.end();
            client = null;
        });

        client.on('close', () => {
            updateMqttStatus(false);
            appendMqttLog("MQTT", "Połączenie zamknięte.");
            client = null;
        });
    }

    function disconnectMQTT() {
        if (client) {
            client.end();
            appendMqttLog("MQTT", "Rozłączanie od brokera...");
        } else {
            appendMqttLog("MQTT", "Klient nie jest połączony.");
        }
    }

    function publishMqttMessage(topic, message) {
        if (isMqttConnected && client) {
            client.publish(topic, JSON.stringify(message), {}, (err) => {
                if (err) {
                    appendMqttLog("PUBLISH ERROR", `Błąd publikacji: ${err.message}`, 'error');
                } else {
                    appendMqttLog(topic, JSON.stringify(message), 'sent');
                }
            });
        } else {
            appendMqttLog("MQTT ERROR", "Brak połączenia MQTT!", 'error');
        }
    }

    // Aktualizacja UI
    function updateUI(data) {
        // Aktualizacja temperatur
        waterTempDisplay.textContent = `${data.water_temp?.toFixed(1) || '0.0'}°C`;
        roomTempDisplay.textContent = `${data.room_temp?.toFixed(1) || '0.0'}°C`;
        burnerTempDisplay.textContent = `${data.burner_temp?.toFixed(1) || '0.0'}°C`;
        exhaustTempDisplay.textContent = `${data.exhaust_temp?.toFixed(1) || '0.0'}°C`;
        
        // Aktualizacja progress bar
        if (waterProgressBar) {
            waterProgressBar.style.width = `${(data.water_temp / 85) * 100}%`;
        }
        
        // Aktualizacja temperatury docelowej
        targetTemp.textContent = `${data.target_temp || 70}°C`;
        targetDisplay.textContent = `${data.target_temp || 70}°C`;
        
        // Aktualizacja statusu płomienia
        if (flameIndicator) {
            flameIndicator.classList.toggle('on', data.flame);
            flameIndicator.classList.toggle('off', !data.flame);
        }
        
        // Aktualizacja statusu zapalarki
        if (igniterIndicator) {
            igniterIndicator.style.display = data.igniter_heating ? 'flex' : 'none';
            if (data.igniter_heating) {
                igniterIndicator.classList.toggle('ready', data.igniter_ready);
            }
        }
        
        // Aktualizacja statusu podajnika i dmuchawy
        if (feederStatusIndicatorMini) {
            feederStatusIndicatorMini.classList.toggle('status-active', data.feeder_active);
        }
        if (blowerStatusIndicatorMini) {
            blowerStatusIndicatorMini.classList.toggle('status-active', data.blower_active);
        }
        
        // Aktualizacja statusu konserwacji
        if (maintenanceStatus) {
            maintenanceStatus.textContent = data.maintenance_active ? 'AKTYWNY' : 'NIEAKTYWNY';
            maintenanceStatus.classList.toggle('maintenance-active', data.maintenance_active);
        }
        
        // Aktualizacja statusu czyszczenia
        if (ashCleaningStatus) {
            ashCleaningStatus.textContent = data.ash_cleaning ? 'TAK' : 'NIE';
            cleaningStatusBadge.classList.toggle('maintenance-active', data.ash_cleaning);
        }
        
        // Aktualizacja statusu podajnika
        if (feederStatus) {
            feederStatus.textContent = data.feeder_active ? 
                'PODAJNIK: DZIAŁA' : 'PODAJNIK: PRZERWA';
            feederStatus.classList.toggle('on', data.feeder_active);
            feederStatus.classList.toggle('off', !data.feeder_active);
        }
        
        // Aktualizacja paska postępu cyklu
        if (cycleProgressBar) {
            cycleProgressBar.style.width = `${(data.feeder_cycle_progress || 0) * 100}%`;
            cycleProgressBar.style.background = data.feeder_active ? 
                'var(--feeder-forward-color)' : 'var(--feeder-pause-color)';
        }
        
        // Aktualizacja timera cyklu
        if (cycleTimer) {
            cycleTimer.textContent = `${data.feeder_cycle_remaining || 0}s`;
        }
        
        // Aktualizacja zużycia peletu
        if (pelletAmount) {
            pelletAmount.textContent = `${(data.pellet_amount || 0).toFixed(2)} kg/h`;
        }
        
        // Aktualizacja mocy dmuchawy
        if (blowerPowerDisplay) {
            blowerPowerDisplay.textContent = `${data.blower_power || 0}%`;
        }
        
        // Aktualizacja czasu pracy
        if (sessionUptimeDisplay) {
            sessionUptimeDisplay.textContent = formatTime(data.session_uptime || 0);
        }
        if (totalUptimeDisplay) {
            totalUptimeDisplay.textContent = formatTime(data.total_uptime || 0);
        }
        
        // Aktualizacja statystyk
        if (rssiDisplay) {
            rssiDisplay.textContent = `${data.rssi || '-0'}dBm`;
        }
        if (ipAddrDisplay) {
            ipAddrDisplay.textContent = data.ip_addr || '0.0.0.0';
        }
        if (burnerHoursDisplay) {
            burnerHoursDisplay.textContent = formatTime(data.burner_hours || 0);
        }
        if (estimatedCostDisplay) {
            estimatedCostDisplay.textContent = `${(data.estimated_cost || 0).toFixed(2)} PLN`;
        }
        
        // Aktualizacja wydajności
        if (efficiencyFill) {
            efficiencyFill.style.width = `${data.efficiency || 0}%`;
            efficiencyLabel.textContent = `${data.efficiency || 0}% Wydajność`;
        }
        
        // Aktualizacja timera czyszczenia
        if (cleanCountdownDisplay) {
            cleanCountdownDisplay.textContent = formatTime(data.clean_countdown || 0);
        }
        
        // Aktualizacja danych wykresów
        const timestamp = data.timestamp_ms || Date.now();
        chartData.water_temp.push({ x: timestamp, y: data.water_temp });
        chartData.room_temp.push({ x: timestamp, y: data.room_temp });
        chartData.burner_temp.push({ x: timestamp, y: data.burner_temp });
        chartData.exhaust_temp.push({ x: timestamp, y: data.exhaust_temp });
        chartData.pellet_consumption.push({ x: timestamp, y: data.pellet_consumption_rate || 0 });
        
        // Ogranicz do 100 punktów
        Object.keys(chartData).forEach(key => {
            if (chartData[key].length > 100) {
                chartData[key].shift();
            }
        });
        
        // Aktualizuj wykresy
        if (temperatureChartInstance) temperatureChartInstance.update();
        if (consumptionChartInstance) consumptionChartInstance.update();
        
        // Aktualizacja średniego zużycia
        if (averagePelletConsumptionDisplay) {
            averagePelletConsumptionDisplay.textContent = 
                `${calculateAverageConsumption().toFixed(2)} kg/h`;
        }
        
        // Aktualizacja obliczeń kosztów
        updateCostCalculation();
    }

    function updateCostCalculation() {
        const pricePerKg = parseFloat(pelletPriceInput.value) || 0;
        const consumptionRate = parseFloat(pelletConsumptionInput.value) || 0;
        const totalHours = parseFloat(totalUptimeDisplay.textContent.split(':')[0]) || 0;
        const totalCost = (pricePerKg * consumptionRate * totalHours).toFixed(2);
        
        if (totalCalculatedCost) {
            totalCalculatedCost.textContent = `${totalCost} PLN`;
        }
    }

    // Inicjalizacja wykresów
    function initializeCharts() {
        const ctxTemp = document.getElementById('temperature-chart').getContext('2d');
        temperatureChartInstance = new Chart(ctxTemp, {
            type: 'line',
            data: {
                datasets: [
                    { 
                        label: 'Woda (°C)', 
                        data: chartData.water_temp, 
                        borderColor: '#3498db', 
                        fill: false, 
                        tension: 0.1,
                        hidden: false
                    },
                    { 
                        label: 'Pokój (°C)', 
                        data: chartData.room_temp, 
                        borderColor: '#2ecc71', 
                        fill: false, 
                        tension: 0.1,
                        hidden: false
                    },
                    { 
                        label: 'Palnik (°C)', 
                        data: chartData.burner_temp, 
                        borderColor: '#e74c3c', 
                        fill: false, 
                        tension: 0.1,
                        hidden: false
                    },
                    { 
                        label: 'Spaliny (°C)', 
                        data: chartData.exhaust_temp, 
                        borderColor: '#f39c12', 
                        fill: false, 
                        tension: 0.1,
                        hidden: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            tooltipFormat: 'HH:mm'
                        },
                        title: {
                            display: true,
                            text: 'Czas'
                        }
                    },
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: 'Temperatura (°C)'
                        }
                    }
                },
                plugins: {
                    zoom: {
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            mode: 'x'
                        },
                        pan: {
                            enabled: true,
                            mode: 'x'
                        }
                    }
                }
            }
        });

        const ctxConsumption = document.getElementById('consumption-chart').getContext('2d');
        consumptionChartInstance = new Chart(ctxConsumption, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Zużycie (kg/h)',
                    data: chartData.pellet_consumption,
                    borderColor: '#d35400',
                    fill: false,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            tooltipFormat: 'HH:mm'
                        },
                        title: {
                            display: true,
                            text: 'Czas'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Zużycie (kg/h)'
                        }
                    }
                },
                plugins: {
                    zoom: {
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            mode: 'x'
                        },
                        pan: {
                            enabled: true,
                            mode: 'x'
                        }
                    }
                }
            }
        });
    }

    // Rejestracja event listenerów
    function setupEventListeners() {
        // Połączenie MQTT
        mqttConnectBtn.addEventListener('click', connectMQTT);
        mqttDisconnectBtn.addEventListener('click', disconnectMQTT);
        
        // Przycisk zasilania
        powerBtn.addEventListener('click', () => {
            publishMqttMessage(MQTT_TOPICS.power, { command: 'toggle' });
        });
        
        // Suwak temperatury
        targetSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            targetDisplay.textContent = `${value}°C`;
            publishMqttMessage(MQTT_TOPICS.targetTemp, { target_temp: value });
        });
        
        // Ustawienia podajnika
        feedTimeInput.addEventListener('change', (e) => {
            publishMqttMessage(MQTT_TOPICS.control, { feed_time: parseInt(e.target.value) });
        });
        
        pauseTimeInput.addEventListener('change', (e) => {
            publishMqttMessage(MQTT_TOPICS.control, { pause_time: parseInt(e.target.value) });
        });
        
        // Ustawienia konserwacji
        maintenanceFeedInput.addEventListener('change', (e) => {
            publishMqttMessage(MQTT_TOPICS.control, { maintenance_feed: parseInt(e.target.value) });
        });
        
        maintenancePauseInput.addEventListener('change', (e) => {
            publishMqttMessage(MQTT_TOPICS.control, { maintenance_pause: parseInt(e.target.value) });
        });
        
        // Sterowanie dmuchawą
        blowerWorkPowerSlider.addEventListener('input', (e) => {
            blowerWorkPowerDisplay.textContent = `${e.target.value}%`;
            publishMqttMessage(MQTT_TOPICS.control, { blower_work_power: parseInt(e.target.value) });
        });
        
        blowerMaintenanceManualPowerSlider.addEventListener('input', (e) => {
            blowerMaintenanceManualPowerDisplay.textContent = `${e.target.value}%`;
            publishMqttMessage(MQTT_TOPICS.control, { blower_maintenance_power: parseInt(e.target.value) });
        });
        
        blowerPurgeManualPowerSlider.addEventListener('input', (e) => {
            blowerPurgeManualPowerDisplay.textContent = `${e.target.value}%`;
            publishMqttMessage(MQTT_TOPICS.control, { blower_purge_power: parseInt(e.target.value) });
        });
        
        // Przełącznik trybu manualnego dmuchawy
        blowerManualToggle.addEventListener('change', (e) => {
            blowerManualControlsDiv.style.display = e.target.checked ? 'block' : 'none';
            publishMqttMessage(MQTT_TOPICS.control, { blower_manual: e.target.checked });
        });
        
        // Przełącznik trybu przedmuchu
        blowerPurgeToggle.addEventListener('change', (e) => {
            blowerPurgeTimesContainer.style.display = e.target.checked ? 'flex' : 'none';
            publishMqttMessage(MQTT_TOPICS.control, { blower_purge: e.target.checked });
        });
        
        // Czyszczenie popiołu
        ashBtn.addEventListener('click', () => {
            publishMqttMessage(MQTT_TOPICS.control, { command: 'ash_clean' });
        });
        
        // Aktualizacja czasu czyszczenia
        updateCleanBtn.addEventListener('click', () => {
            const hours = parseInt(cleanHoursInput.value) || 0;
            const minutes = parseInt(cleanMinutesInput.value) || 0;
            const seconds = parseInt(cleanSecondsInput.value) || 0;
            const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
            publishMqttMessage(MQTT_TOPICS.control, { clean_countdown: totalSeconds });
        });
        
        // Resetowanie statystyk
        resetSessionUptimeBtn.addEventListener('click', () => {
            publishMqttMessage(MQTT_TOPICS.control, { command: 'reset_session' });
        });
        
        resetHistoryBtn.addEventListener('click', () => {
            if (resetPasswordInput.value === mqttPasswordInput.value) {
                publishMqttMessage(MQTT_TOPICS.control, { command: 'reset_history' });
                resetMessageDiv.textContent = 'Dane zresetowane!';
                setTimeout(() => resetMessageDiv.textContent = '', 3000);
            } else {
                resetMessageDiv.textContent = 'Nieprawidłowe hasło!';
                setTimeout(() => resetMessageDiv.textContent = '', 3000);
            }
        });
        
        // Obliczanie kosztów
        pelletPriceInput.addEventListener('input', updateCostCalculation);
        
        // Przełączniki wykresów temperatury
        temperatureChartToggles.querySelectorAll('.dataset-toggle').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
                const dataset = toggle.getAttribute('data-chart');
                const index = chartDatasetMap[dataset];
                
                if (temperatureChartInstance && temperatureChartInstance.data.datasets[index]) {
                    temperatureChartInstance.data.datasets[index].hidden = !toggle.classList.contains('active');
                    temperatureChartInstance.update();
                }
            });
        });
        
        // Przełączniki głównych wykresów
        mainChartSwitcher.querySelectorAll('.chart-switch').forEach(switchBtn => {
            switchBtn.addEventListener('click', () => {
                mainChartSwitcher.querySelectorAll('.chart-switch').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                switchBtn.classList.add('active');
                const chartType = switchBtn.getAttribute('data-chart-type');
                
                chartContainerTemp.style.display = chartType === 'temperature' ? 'block' : 'none';
                chartContainerConsumption.style.display = chartType === 'consumption' ? 'block' : 'none';
            });
        });
        
        // Przyciski zakresu historycznego
        historyRangeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                historyRangeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const range = btn.getAttribute('data-range');
                let minutes = 60;
                
                switch (range) {
                    case '6h': minutes = 360; break;
                    case '24h': minutes = 1440; break;
                    case '7d': minutes = 10080; break;
                    default: minutes = 60;
                }
                
                const cutoff = Date.now() - (minutes * 60 * 1000);
                
                // Aktualizuj dane wykresów
                temperatureChartInstance.data.datasets.forEach(dataset => {
                    dataset.data = dataset.data.filter(point => point.x >= cutoff);
                });
                
                consumptionChartInstance.data.datasets[0].data = 
                    consumptionChartInstance.data.datasets[0].data.filter(point => point.x >= cutoff);
                
                temperatureChartInstance.update();
                consumptionChartInstance.update();
            });
        });
        
        // Kontrolki zoomu
        document.getElementById('zoom-in').addEventListener('click', () => {
            temperatureChartInstance.zoom(1.1);
        });
        
        document.getElementById('zoom-out').addEventListener('click', () => {
            temperatureChartInstance.zoom(0.9);
        });
        
        document.getElementById('zoom-reset').addEventListener('click', () => {
            temperatureChartInstance.resetZoom();
        });
    }

    // Inicjalizacja
    initializeCharts();
    setupEventListeners();
    connectMQTT();
});
