document.addEventListener('DOMContentLoaded', () => {
    const powerButton = document.getElementById('power-button');
    const targetTempInput = document.getElementById('targetTemp');
    const targetTempDisplay = document.getElementById('targetTempDisplay');
    const waterTempDisplay = document.getElementById('waterTempDisplay');
    const roomTempDisplay = document.getElementById('roomTempDisplay');
    const burnerTempDisplay = document.getElementById('burnerTempDisplay');
    const exhaustTempDisplay = document.getElementById('exhaustTempDisplay');
    const flameStatus = document.getElementById('flameStatus');
    const igniterStateDisplay = document.getElementById('igniterStateDisplay');
    const igniterTempDisplay = document.getElementById('igniterTempDisplay');
    const ashCleaningStatus = document.getElementById('ashCleaningStatus');
    const autoCleanSwitch = document.getElementById('autoCleanSwitch');
    const cleanTimerDisplay = document.getElementById('cleanTimerDisplay');
    const lastUpdateDisplay = document.getElementById('lastUpdateDisplay');
    const feederActiveDisplay = document.getElementById('feederActiveDisplay');
    const blowerActiveDisplay = document.getElementById('blowerActiveDisplay');
    const mqttStatus = document.getElementById('mqtt-status');
    const mqttStatusIcon = document.getElementById('mqtt-status-icon');
    const logContainer = document.getElementById('log-container');
    const feederProgressBar = document.getElementById('feederProgressBar');
    const blowerProgressBar = document.getElementById('blowerProgressBar');
    const maintenanceModeDisplay = document.getElementById('maintenanceModeDisplay');
    const maintenanceSwitch = document.getElementById('maintenanceSwitch');
    const feedOnTimeInput = document.getElementById('feedOnTimeInput');
    const feedOffTimeInput = document.getElementById('feedOffTimeInput');
    const maintenanceFeedOnTimeInput = document.getElementById('maintenanceFeedOnTimeInput');
    const maintenanceFeedOffTimeInput = document.getElementById('maintenanceFeedOffTimeInput');
    const blowerManualControlSwitch = document.getElementById('blowerManualControlSwitch');
    const blowerWorkPowerSlider = document.getElementById('blowerWorkPower');
    const blowerPurgeManualPowerSlider = document.getElementById('blowerPurgeManualPower');
    const blowerMaintenanceManualPowerSlider = document.getElementById('blowerMaintenanceManualPower');
    const effectiveBlowerPowerDisplay = document.getElementById('effectiveBlowerPowerDisplay');
    const blowerWorkPowerDisplay = document.getElementById('blowerWorkPowerDisplay');
    const blowerPurgeManualPowerDisplay = document.getElementById('blowerPurgeManualPowerDisplay');
    const blowerMaintenanceManualPowerDisplay = document.getElementById('blowerMaintenanceManualPowerDisplay');
    const feederCycleStatusDisplay = document.getElementById('feederCycleStatus');
    const feederCycleProgressBar = document.getElementById('feederCycleProgressBar');
    const timeRemainingInPhaseDisplay = document.getElementById('timeRemainingInPhase');
    const currentPhaseDurationDisplay = document.getElementById('currentPhaseDuration');
    const blowerPurgeModeSwitch = document.getElementById('blowerPurgeModeSwitch');
    const blowerPurgeOnTimeInput = document.getElementById('blowerPurgeOnTimeInput');
    const blowerPurgeOffTimeInput = document.getElementById('blowerPurgeOffTimeInput');
    const blowerPurgeStatusDisplay = document.getElementById('blowerPurgeStatusDisplay');
    const blowerPurgeProgressBar = document.getElementById('blowerPurgeProgressBar');
    const currentPelletConsumptionRateDisplay = document.getElementById('currentPelletConsumptionRateDisplay');
    const totalUptimeDisplay = document.getElementById('totalUptimeDisplay');
    const costPerKgInput = document.getElementById('costPerKg');
    const boilerPowerKwInput = document.getElementById('boilerPowerKw');
    const calculateCostBtn = document.getElementById('calculateCostBtn');
    const dailyPelletCostDisplay = document.getElementById('dailyPelletCost');
    const monthlyPelletCostDisplay = document.getElementById('monthlyPelletCost');
    const annualPelletCostDisplay = document.getElementById('annualPelletCost');
    const dailyEnergyCostDisplay = document.getElementById('dailyEnergyCost');
    const monthlyEnergyCostDisplay = document('monthlyEnergyCost');
    const annualEnergyCostDisplay = document.getElementById('annualEnergyCost');
    const totalDailyCostDisplay = document.getElementById('totalDailyCost');
    const totalMonthlyCostDisplay = document.getElementById('totalMonthlyCost');
    const totalAnnualCostDisplay = document.getElementById('totalAnnualCost');
    const pelletConsumptionRateGraph = document.getElementById('pelletConsumptionRateGraph');
    const uptimeHistoryChartCanvas = document.getElementById('uptimeHistoryChart');
    const avgConsumptionRateDisplay = document.getElementById('avgConsumptionRateDisplay');
    const totalPelletConsumedDisplay = document.getElementById('totalPelletConsumedDisplay');
    const totalCostOfPelletDisplay = document.getElementById('totalCostOfPellet');
    const avgBoilerPowerKwDisplay = document.getElementById('avgBoilerPowerKwDisplay');
    const totalEnergyConsumedKwhDisplay = document.getElementById('totalEnergyConsumedKwh');
    const totalEnergyCostDisplay = document.getElementById('totalEnergyCost');

    let historyChart;
    let uptimeChart;
    let mqttClient;
    let deviceOnline = false;
    let state = {};
    const MAX_LOG_ENTRIES = 50;

    // Funkcja do aktualizacji interfejsu
    function updateUI(newState) {
        state = newState; // Aktualizuj globalny stan
        document.getElementById('boiler-status-value').textContent = state.power ? 'W³¹czony' : 'Wy³¹czony';
        document.getElementById('boiler-status-value').className = state.power ? 'status-active' : 'status-inactive';
        powerButton.textContent = state.power ? 'Wy³¹cz Piec' : 'W³¹cz Piec';
        powerButton.className = state.power ? 'power-off' : 'success';

        targetTempDisplay.textContent = state.targetTemp;
        targetTempInput.value = state.targetTemp;
        waterTempDisplay.textContent = state.waterTemp.toFixed(1);
        roomTempDisplay.textContent = state.roomTemp.toFixed(1);
        burnerTempDisplay.textContent = state.burnerTemp.toFixed(1);
        exhaustTempDisplay.textContent = state.exhaustTemp.toFixed(1);

        flameStatus.textContent = state.flame ? 'Aktywny' : 'Brak';
        flameStatus.className = state.flame ? 'status-active' : 'status-inactive';
        document.getElementById('flame-indicator').className = state.flame ? 'flame-indicator on' : 'flame-indicator off';

        igniterStateDisplay.textContent = state.igniterState;
        igniterTempDisplay.textContent = state.igniterTemp.toFixed(1);

        const igniterIndicator = document.getElementById('igniter-indicator');
        const ignitionStatus = document.getElementById('ignition-status');
        const ignitionTimer = document.getElementById('ignition-timer');
        const ignitionProgressCircle = document.getElementById('ignition-progress-circle');
        const ignitionProgressText = document.getElementById('ignition-progress-text');

        // Resetuj widocznoœæ i klasy
        igniterIndicator.style.display = 'none';
        ignitionStatus.className = 'ignition-status';
        ignitionTimer.style.display = 'none';
        ignitionProgressCircle.style.display = 'none';
        ignitionProgressText.textContent = '';
        ignitionProgressCircle.style.background = 'conic-gradient(#ff9800 0%,#ff5722 0%,rgba(0,0,0,0.3) 0%)';

        switch (state.igniterState) {
            case 'off':
                ignitionStatus.textContent = 'Wy³¹czony';
                ignitionStatus.classList.add('off');
                break;
            case 'heating':
                ignitionStatus.textContent = 'Grzanie';
                ignitionStatus.classList.add('heating');
                igniterIndicator.style.display = 'flex';
                igniterIndicator.classList.remove('ready'); // Upewnij siê, ¿e nie ma klasy ready
                break;
            case 'ready':
                ignitionStatus.textContent = 'Gotowy do zap³onu';
                ignitionStatus.classList.add('ready');
                igniterIndicator.style.display = 'flex';
                igniterIndicator.classList.add('ready');
                break;
            case 'on':
                ignitionStatus.textContent = 'Zapalony';
                ignitionStatus.classList.add('on');
                igniterIndicator.style.display = 'none'; // Zapalarka wy³¹czona, gdy p³omieñ jest aktywny
                break;
            default:
                ignitionStatus.textContent = state.igniterState; // Wyœwietl nieznany stan
                break;
        }

        ashCleaningStatus.textContent = state.ashCleaning ? 'W Trakcie' : 'Zakoñczone';
        ashCleaningStatus.className = state.ashCleaning ? 'status-active' : 'status-inactive';

        autoCleanSwitch.checked = state.autoClean;
        updateCleanTimer(state.timeToClean);

        feederActiveDisplay.textContent = state.feederActive ? 'Aktywny' : 'Nieaktywny';
        feederActiveDisplay.className = state.feederActive ? 'status-active' : 'status-inactive';

        blowerActiveDisplay.textContent = state.blowerActive ? 'Aktywna' : 'Nieaktywna';
        blowerActiveDisplay.className = state.blowerActive ? 'status-active' : 'status-inactive';

        maintenanceModeDisplay.textContent = state.maintenanceMode ? 'Aktywny' : 'Wy³¹czony';
        maintenanceModeDisplay.className = state.maintenanceMode ? 'status-active' : 'status-inactive';
        maintenanceSwitch.checked = state.maintenanceMode;

        feedOnTimeInput.value = state.feedOnTime;
        feedOffTimeInput.value = state.feedOffTime;
        maintenanceFeedOnTimeInput.value = state.maintenanceFeedOnTime;
        maintenanceFeedOffTimeInput.value = state.maintenanceFeedOffTime;

        blowerManualControlSwitch.checked = state.blowerManualControl;
        blowerWorkPowerSlider.value = state.blowerWorkPower;
        blowerPurgeManualPowerSlider.value = state.blowerPurgeManualPower;
        blowerMaintenanceManualPowerSlider.value = state.blowerMaintenanceManualPower;
        effectiveBlowerPowerDisplay.textContent = state.effectiveBlowerPower + '%';
        blowerWorkPowerDisplay.textContent = state.blowerWorkPower + '%';
        blowerPurgeManualPowerDisplay.textContent = state.blowerPurgeManualPower + '%';
        blowerMaintenanceManualPowerDisplay.textContent = state.blowerMaintenanceManualPower + '%';

        // Aktualizacja postêpu dmuchawy i podajnika
        const feederProgress = state.feedOnTime > 0 ? (state.feedOnTime / (state.feedOnTime + state.feedOffTime)) * 100 : 0;
        feederProgressBar.style.width = `${feederProgress}%`;

        const blowerProgress = state.effectiveBlowerPower; // Effective power is already 0-100%
        blowerProgressBar.style.width = `${blowerProgress}%`;

        // Aktualizacja stanu cyklu podajnika
        updateFeederCycleUI(state.feederCycleState, state.timeRemainingInPhase, state.currentPhaseDuration);

        // Aktualizacja trybu przedmuchu dmuchawy
        blowerPurgeModeSwitch.checked = state.blowerPurgeMode;
        blowerPurgeOnTimeInput.value = state.blowerPurgeOnTime;
        blowerPurgeOffTimeInput.value = state.blowerPurgeOffTime;
        updateBlowerPurgeUI(state.blowerPurgeMode, state.timeRemainingInPhase, state.currentPhaseDuration);

        currentPelletConsumptionRateDisplay.textContent = state.currentPelletConsumptionRate.toFixed(2); // kg/h
        pelletConsumptionRateGraph.style.width = `${(state.currentPelletConsumptionRate / 3.0 * 100).toFixed(0)}%`;

        totalUptimeDisplay.textContent = formatTime(state.totalUptimeSeconds);
        updateDashboardCharts();
        updateHistoryStats();
        updateCostCalculations();

        // Aktualizacja czasu ostatniej aktualizacji
        if (state.timestamp_ms) {
            const lastUpdateDateTime = luxon.DateTime.fromMillis(state.timestamp_ms);
            lastUpdateDisplay.textContent = lastUpdateDateTime.toFormat('yyyy-MM-dd HH:mm:ss');
            deviceOnline = true; // Urz¹dzenie jest online, jeœli otrzymujemy timestamp
        } else {
            lastUpdateDisplay.textContent = 'Brak danych';
            deviceOnline = false;
        }
        updateConnectionStatus(); // Aktualizuj status po³¹czenia
    }

    function updateFeederCycleUI(cycleState, timeRemainingMs, currentPhaseDurationMs) {
        let statusText = '';
        let progressBarColor = '';
        let progressPercent = 0;

        if (currentPhaseDurationMs > 0) {
            progressPercent = ((currentPhaseDurationMs - timeRemainingMs) / currentPhaseDurationMs) * 100;
        }

        switch (cycleState) {
            case 0: // FEED_OFF
                statusText = 'Podajnik: Wy³¹czony (przerwa)';
                progressBarColor = 'var(--feeder-pause-color)';
                feederCycleProgressBar.style.width = `0%`; // Brak paska dla d³ugiej przerwy
                break;
            case 1: // FEED_FORWARD
                statusText = 'Podajnik: Podawanie';
                progressBarColor = 'var(--feeder-forward-color)';
                feederCycleProgressBar.style.width = `${progressPercent}%`;
                break;
            case 2: // FEED_SHORT_PAUSE
                statusText = 'Podajnik: Krótka przerwa';
                progressBarColor = 'var(--feeder-pause-color)';
                feederCycleProgressBar.style.width = `${progressPercent}%`;
                break;
            case 3: // FEED_REVERSE
                statusText = 'Podajnik: RozluŸnianie (cofanie)';
                progressBarColor = 'var(--feeder-reverse-color)';
                feederCycleProgressBar.style.width = `${progressPercent}%`;
                break;
        }
        feederCycleStatusDisplay.textContent = statusText;
        feederCycleProgressBar.style.background = progressBarColor;
        timeRemainingInPhaseDisplay.textContent = (timeRemainingMs / 1000).toFixed(0) + 's';
        currentPhaseDurationDisplay.textContent = (currentPhaseDurationMs / 1000).toFixed(0) + 's';
    }

    function updateBlowerPurgeUI(isPurgeMode, timeRemainingMs, currentPhaseDurationMs) {
        let statusText = '';
        let progressPercent = 0;

        if (currentPhaseDurationMs > 0) {
            progressPercent = ((currentPhaseDurationMs - timeRemainingMs) / currentPhaseDurationMs) * 100;
        }

        if (isPurgeMode) {
            statusText = 'Przedmuch: Aktywny';
            blowerPurgeStatusDisplay.classList.add('on');
            blowerPurgeStatusDisplay.classList.remove('off');
            blowerPurgeProgressBar.style.width = `${progressPercent}%`;
            blowerPurgeProgressBar.style.background = 'linear-gradient(90deg, var(--blower-color), #16a085)';
        } else {
            statusText = 'Przedmuch: Wy³¹czony';
            blowerPurgeStatusDisplay.classList.add('off');
            blowerPurgeStatusDisplay.classList.remove('on');
            blowerPurgeProgressBar.style.width = `0%`;
        }
        blowerPurgeStatusDisplay.textContent = statusText;
    }


    function updateConnectionStatus() {
        if (mqttClient.connected && deviceOnline) {
            mqttStatus.textContent = 'Po³¹czono';
            mqttStatusIcon.classList.remove('status-inactive');
            mqttStatusIcon.classList.add('status-active');
        } else if (mqttClient.connected && !deviceOnline) {
            mqttStatus.textContent = 'MQTT OK, urz¹dzenie offline';
            mqttStatusIcon.classList.remove('status-active');
            mqttStatusIcon.classList.add('status-warning'); // ¯ó³ty dla po³¹czonego MQTT, ale brak danych z ESP
        } else {
            mqttStatus.textContent = 'Roz³¹czono';
            mqttStatusIcon.classList.remove('status-active');
            mqttStatusIcon.classList.add('status-inactive');
        }
    }

    function appendLog(message, type = 'info') {
        const logEntry = document.createElement('div');
        logEntry.classList.add('log-entry');
        const timestamp = luxon.DateTime.local().toFormat('HH:mm:ss');
        logEntry.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`;
        logContainer.prepend(logEntry); // Dodaj na pocz¹tek

        // Ogranicz liczbê wpisów
        while (logContainer.children.length > MAX_LOG_ENTRIES) {
            logContainer.removeChild(logContainer.lastChild);
        }
    }

    // MQTT setup
    function connectMqtt() {
        // U¿yj wss dla GitHub Pages (jeœli broker obs³uguje)
        // Jeœli nie, zostaw mqtt:// i upewnij siê, ¿e masz bezpieczne po³¹czenie, lub testuj lokalnie
        mqttClient = mqtt.connect('wss://broker.emqx.io:8084/mqtt', {
            clientId: 'web_dashboard_' + Math.random().toString(16).substr(2, 8),
            username: 'agentsan007',
            password: 'Sanders24*',
            clean: true,
            reconnectPeriod: 5000 // Spróbuj ponownie co 5 sekund
        });

        mqttClient.on('connect', () => {
            console.log('Connected to MQTT broker');
            appendLog('Po³¹czono z brokerem MQTT.', 'success');
            mqttClient.subscribe('pellet/boiler/state');
            updateConnectionStatus();
        });

        mqttClient.on('message', (topic, message) => {
            try {
                const data = JSON.parse(message.toString());
                console.log('Received state:', data);
                updateUI(data);
                // Dodaj punkt do historii wykresów
                if (data.timestamp_ms && data.waterTemp !== undefined && data.burnerTemp !== undefined && data.exhaustTemp !== undefined && data.roomTemp !== undefined) {
                    addHistoryPoint(data);
                }
            } catch (e) {
                console.error('Failed to parse MQTT message:', e);
                appendLog(`B³¹d parsowania wiadomoœci MQTT: ${e.message}`, 'error');
            }
        });

        mqttClient.on('close', () => {
            console.log('MQTT connection closed');
            appendLog('Po³¹czenie MQTT zamkniête.', 'warning');
            deviceOnline = false;
            updateConnectionStatus();
        });

        mqttClient.on('offline', () => {
            console.log('MQTT client is offline');
            appendLog('Klient MQTT offline.', 'warning');
            deviceOnline = false;
            updateConnectionStatus();
        });

        mqttClient.on('error', (err) => {
            console.error('MQTT error:', err);
            appendLog(`B³¹d MQTT: ${err.message}`, 'error');
            deviceOnline = false;
            updateConnectionStatus();
            mqttClient.end(); // Zakoñcz po³¹czenie, aby spróbowaæ ponownie
        });
    }

    function publishControl(payload) {
        if (mqttClient.connected) {
            mqttClient.publish('pellet/boiler/control', JSON.stringify(payload), {
                qos: 0,
                retain: false
            });
            console.log('Published control:', payload);
            appendLog(`Wys³ano polecenie steruj¹ce: ${JSON.stringify(payload)}`, 'info');
        } else {
            appendLog('B³¹d: Brak po³¹czenia MQTT, nie mo¿na wys³aæ polecenia.', 'error');
            console.warn('MQTT not connected, cannot publish.');
        }
    }

    // Obs³uga klikniêæ przycisków i zmian suwaków
    powerButton.addEventListener('click', () => {
        publishControl({
            power: !state.power
        });
    });

    targetTempInput.addEventListener('change', () => {
        publishControl({
            targetTemp: parseFloat(targetTempInput.value)
        });
    });

    document.getElementById('startCleanBtn').addEventListener('click', () => {
        if (confirm('Czy na pewno chcesz rozpocz¹æ rêczne czyszczenie pieca?')) {
            publishControl({
                startCleaning: true
            });
        }
    });

    autoCleanSwitch.addEventListener('change', () => {
        publishControl({
            autoClean: autoCleanSwitch.checked
        });
    });

    maintenanceSwitch.addEventListener('change', () => {
        publishControl({
            maintenanceMode: maintenanceSwitch.checked
        });
    });

    feedOnTimeInput.addEventListener('change', () => {
        publishControl({
            feedOnTime: parseInt(feedOnTimeInput.value)
        });
    });
    feedOffTimeInput.addEventListener('change', () => {
        publishControl({
            feedOffTime: parseInt(feedOffTimeInput.value)
        });
    });
    maintenanceFeedOnTimeInput.addEventListener('change', () => {
        publishControl({
            maintenanceFeedOnTime: parseInt(maintenanceFeedOnTimeInput.value)
        });
    });
    maintenanceFeedOffTimeInput.addEventListener('change', () => {
        publishControl({
            maintenanceFeedOffTime: parseInt(maintenanceFeedOffTimeInput.value)
        });
    });

    blowerManualControlSwitch.addEventListener('change', () => {
        publishControl({
            blowerManualControl: blowerManualControlSwitch.checked
        });
    });
    blowerWorkPowerSlider.addEventListener('input', () => {
        blowerWorkPowerDisplay.textContent = blowerWorkPowerSlider.value + '%';
        publishControl({
            blowerWorkPower: parseInt(blowerWorkPowerSlider.value)
        });
    });
    blowerPurgeManualPowerSlider.addEventListener('input', () => {
        blowerPurgeManualPowerDisplay.textContent = blowerPurgeManualPowerSlider.value + '%';
        publishControl({
            blowerPurgeManualPower: parseInt(blowerPurgeManualPowerSlider.value)
        });
    });
    blowerMaintenanceManualPowerSlider.addEventListener('input', () => {
        blowerMaintenanceManualPowerDisplay.textContent = blowerMaintenanceManualPowerSlider.value + '%';
        publishControl({
            blowerMaintenanceManualPower: parseInt(blowerMaintenanceManualPowerSlider.value)
        });
    });

    blowerPurgeModeSwitch.addEventListener('change', () => {
        publishControl({
            blowerPurgeMode: blowerPurgeModeSwitch.checked
        });
    });
    blowerPurgeOnTimeInput.addEventListener('change', () => {
        publishControl({
            blowerPurgeOnTime: parseInt(blowerPurgeOnTimeInput.value)
        });
    });
    blowerPurgeOffTimeInput.addEventListener('change', () => {
        publishControl({
            blowerPurgeOffTime: parseInt(blowerPurgeOffTimeInput.value)
        });
    });

    // Obs³uga suwaków do aktualizacji wartoœci na ¿ywo
    blowerWorkPowerSlider.addEventListener('input', () => {
        blowerWorkPowerDisplay.textContent = blowerWorkPowerSlider.value + '%';
    });
    blowerPurgeManualPowerSlider.addEventListener('input', () => {
        blowerPurgeManualPowerDisplay.textContent = blowerPurgeManualPowerSlider.value + '%';
    });
    blowerMaintenanceManualPowerSlider.addEventListener('input', () => {
        blowerMaintenanceManualPowerDisplay.textContent = blowerMaintenanceManualPowerSlider.value + '%';
    });


    // Funkcje dla wykresów
    function initCharts() {
        const ctxHistory = document.getElementById('historyChart').getContext('2d');
        historyChart = new Chart(ctxHistory, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Temperatura Wody',
                    data: [],
                    borderColor: '#3498db',
                    tension: 0.3,
                    fill: false,
                    yAxisID: 'y',
                    hidden: false
                }, {
                    label: 'Temperatura Palnika',
                    data: [],
                    borderColor: '#e74c3c',
                    tension: 0.3,
                    fill: false,
                    yAxisID: 'y',
                    hidden: false
                }, {
                    label: 'Temperatura Spalin',
                    data: [],
                    borderColor: '#f39c12',
                    tension: 0.3,
                    fill: false,
                    yAxisID: 'y',
                    hidden: false
                }, {
                    label: 'Temperatura Pomieszczenia',
                    data: [],
                    borderColor: '#2ecc71',
                    tension: 0.3,
                    fill: false,
                    yAxisID: 'y',
                    hidden: true
                }, {
                    label: 'Zu¿ycie Pelletu (kg/h)',
                    data: [],
                    borderColor: '#d35400',
                    tension: 0.3,
                    fill: false,
                    yAxisID: 'y1',
                    hidden: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            tooltipFormat: 'HH:mm:ss',
                            displayFormats: {
                                minute: 'HH:mm'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Czas',
                            color: 'white'
                        },
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        },
                        ticks: {
                            color: 'white'
                        }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Temperatura (°C)',
                            color: 'white'
                        },
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        },
                        ticks: {
                            color: 'white'
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Zu¿ycie Pelletu (kg/h)',
                            color: 'white'
                        },
                        grid: {
                            drawOnChartArea: false // Only draw grid lines for the first Y axis
                        },
                        ticks: {
                            color: 'white'
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: 'white'
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x',
                            threshold: 10
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'x',
                        }
                    }
                }
            }
        });

        // Inicjalizacja wykresu historii czasu pracy
        const ctxUptime = uptimeHistoryChartCanvas.getContext('2d');
        uptimeChart = new Chart(ctxUptime, {
            type: 'bar',
            data: {
                labels: ['Dzisiaj', 'Wczoraj', 'Ostatnie 7 dni', 'Ostatnie 30 dni', 'Ca³kowity'],
                datasets: [{
                    label: 'Czas pracy (godziny)',
                    data: [0, 0, 0, 0, 0],
                    backgroundColor: [
                        'rgba(52, 152, 219, 0.6)', // Dzisiaj
                        'rgba(46, 204, 113, 0.6)', // Wczoraj
                        'rgba(243, 156, 18, 0.6)', // 7 dni
                        'rgba(155, 89, 182, 0.6)', // 30 dni
                        'rgba(231, 76, 60, 0.6)' // Ca³kowity
                    ],
                    borderColor: [
                        'rgba(52, 152, 219, 1)',
                        'rgba(46, 204, 113, 1)',
                        'rgba(243, 156, 18, 1)',
                        'rgba(155, 89, 182, 1)',
                        'rgba(231, 76, 60, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        ticks: {
                            color: 'white'
                        },
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Czas pracy (godziny)',
                            color: 'white'
                        },
                        ticks: {
                            color: 'white'
                        },
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + 'h';
                            }
                        }
                    }
                }
            }
        });
    }

    // Funkcja do dodawania punktów do historii wykresu
    const MAX_HISTORY_POINTS_CHART = 60; // Maksymalnie 60 punktów na wykresie (60 minut)
    function addHistoryPoint(data) {
        const timestamp = luxon.DateTime.fromMillis(data.timestamp_ms);

        if (historyChart.data.labels.length >= MAX_HISTORY_POINTS_CHART) {
            historyChart.data.labels.shift();
            historyChart.data.datasets.forEach(dataset => {
                dataset.data.shift();
            });
        }

        historyChart.data.labels.push(timestamp);
        historyChart.data.datasets[0].data.push({
            x: timestamp,
            y: data.waterTemp
        });
        historyChart.data.datasets[1].data.push({
            x: timestamp,
            y: data.burnerTemp
        });
        historyChart.data.datasets[2].data.push({
            x: timestamp,
            y: data.exhaustTemp
        });
        historyChart.data.datasets[3].data.push({
            x: timestamp,
            y: data.roomTemp
        });
        historyChart.data.datasets[4].data.push({
            x: timestamp,
            y: data.currentPelletConsumptionRate
        });

        historyChart.update();
    }

    // Funkcja do aktualizacji statystyk na podstawie historii (tymczasowo z mocka lub z ostatniego stanu)
    function updateHistoryStats() {
        // Docelowo te dane powinny byæ dostarczane przez ESP32 z agregacji historyData
        // Na potrzeby tej wersji, u¿yjemy prostych obliczeñ na podstawie aktualnego stanu
        const totalUptimeHours = state.totalUptimeSeconds / 3600;
        totalUptimeDisplay.textContent = formatTime(state.totalUptimeSeconds);

        // Tymczasowe dane dla wykresu czasu pracy (mockowe lub bardzo uproszczone)
        // W realnym systemie ESP32 powinno agregowaæ te dane i wysy³aæ je jako czêœæ stanu
        const todayUptime = (state.totalUptimeSeconds % (24 * 3600)) / 3600; // Uproszczone: czas pracy z dzisiaj
        const yesterdayUptime = (state.totalUptimeSeconds / 3600) * 0.1; // Uproszczone: 10% ca³kowitego czasu to wczoraj
        const last7DaysUptime = (state.totalUptimeSeconds / 3600) * 0.5; // Uproszczone
        const last30DaysUptime = (state.totalUptimeSeconds / 3600) * 0.8; // Uproszczone

        uptimeChart.data.datasets[0].data = [
            todayUptime,
            yesterdayUptime,
            last7DaysUptime,
            last30DaysUptime,
            totalUptimeHours
        ];
        uptimeChart.update();

        // Obliczenia œredniego zu¿ycia i kosztów
        avgConsumptionRateDisplay.textContent = state.currentPelletConsumptionRate.toFixed(2); // U¿ywamy aktualnego, bo brak historii
        totalPelletConsumedDisplay.textContent = (state.currentPelletConsumptionRate * totalUptimeHours).toFixed(2); // Uproszczone
        avgBoilerPowerKwDisplay.textContent = (state.effectiveBlowerPower / 100 * 5).toFixed(2); // Uproszczone
    }


    // Funkcja do formatowania czasu
    function formatTime(seconds) {
        const days = Math.floor(seconds / (3600 * 24));
        seconds %= (3600 * 24);
        const hours = Math.floor(seconds / 3600);
        seconds %= 3600;
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;

        let parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0 || days > 0) parts.push(`${hours}h`); // Poka¿ godziny jeœli s¹ dni lub godziny
        parts.push(`${minutes}m`);
        parts.push(`${remainingSeconds}s`);

        return parts.join(' ');
    }

    function updateCleanTimer(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        cleanTimerDisplay.textContent = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    // Obs³uga prze³¹czników widocznoœci datasetów w wykresie historii
    document.querySelectorAll('.dataset-toggle').forEach(toggle => {
        toggle.addEventListener('click', () => {
            const datasetIndex = parseInt(toggle.dataset.datasetIndex);
            const dataset = historyChart.data.datasets[datasetIndex];
            dataset.hidden = !dataset.hidden;
            toggle.classList.toggle('active', !dataset.hidden);
            historyChart.update();
        });
    });

    // Funkcja do obliczania kosztów
    function updateCostCalculations() {
        const costPerKg = parseFloat(costPerKgInput.value);
        const boilerPowerKw = parseFloat(boilerPowerKwInput.value);

        if (isNaN(costPerKg) || isNaN(boilerPowerKw) || boilerPowerKw <= 0) {
            dailyPelletCostDisplay.textContent = 'N/A';
            monthlyPelletCostDisplay.textContent = 'N/A';
            annualPelletCostDisplay.textContent = 'N/A';
            dailyEnergyCostDisplay.textContent = 'N/A';
            monthlyEnergyCostDisplay.textContent = 'N/A';
            annualEnergyCostDisplay.textContent = 'N/A';
            totalDailyCostDisplay.textContent = 'N/A';
            totalMonthlyCostDisplay.textContent = 'N/A';
            totalAnnualCostDisplay.textContent = 'N/A';
            return;
        }

        const avgConsumption = state.currentPelletConsumptionRate || 0; // kg/h
        const avgPowerConsumption = boilerPowerKw * (state.effectiveBlowerPower / 100) || 0; // kW (uproszczone)
        const dailyOperatingHours = state.power ? 24 : 0; // Bardzo uproszczone, docelowo z historii uptime

        const dailyPellet = avgConsumption * dailyOperatingHours;
        const dailyEnergy = avgPowerConsumption * dailyOperatingHours;

        dailyPelletCostDisplay.textContent = (dailyPellet * costPerKg).toFixed(2);
        monthlyPelletCostDisplay.textContent = (dailyPellet * costPerKg * 30).toFixed(2);
        annualPelletCostDisplay.textContent = (dailyPellet * costPerKg * 365).toFixed(2);

        // Za³o¿enie sta³ej ceny energii elektrycznej np. 0.70 PLN/kWh
        const electricityCostPerKwh = 0.70; // PLN
        dailyEnergyCostDisplay.textContent = (dailyEnergy * electricityCostPerKwh).toFixed(2);
        monthlyEnergyCostDisplay.textContent = (dailyEnergy * electricityCostPerKwh * 30).toFixed(2);
        annualEnergyCostDisplay.textContent = (dailyEnergy * electricityCostPerKwh * 365).toFixed(2);

        totalDailyCostDisplay.textContent = ((dailyPellet * costPerKg) + (dailyEnergy * electricityCostPerKwh)).toFixed(2);
        totalMonthlyCostDisplay.textContent = (((dailyPellet * costPerKg) + (dailyEnergy * electricityCostPerKwh)) * 30).toFixed(2);
        totalAnnualCostDisplay.textContent = (((dailyPellet * costPerKg) + (dailyEnergy * electricityCostPerKwh)) * 365).toFixed(2);

        // Aktualizacja statystyk historii
        const totalPelletC = parseFloat(totalPelletConsumedDisplay.textContent) || 0;
        totalCostOfPelletDisplay.textContent = (totalPelletC * costPerKg).toFixed(2);

        const totalEnergyC = parseFloat(totalEnergyConsumedKwhDisplay.textContent) || 0;
        totalEnergyCostDisplay.textContent = (totalEnergyC * electricityCostPerKwh).toFixed(2);
    }

    costPerKgInput.addEventListener('input', updateCostCalculations);
    boilerPowerKwInput.addEventListener('input', updateCostCalculations);
    calculateCostBtn.addEventListener('click', updateCostCalculations);


    // Tryb edycji czasu czyszczenia
    const editCleanTimeBtn = document.getElementById('edit-clean-time-btn');
    const updateCleanBtn = document.getElementById('update-clean-btn');
    const editCleanContainer = document.getElementById('edit-clean-container');
    const cleanTimeHourInput = document.getElementById('cleanTimeHour');
    const cleanTimeMinuteInput = document.getElementById('cleanTimeMinute');
    const cleanTimeSecondInput = document.getElementById('cleanTimeSecond');

    editCleanTimeBtn.addEventListener('click', () => {
        editCleanContainer.style.display = 'block';
        // Wype³nij pola aktualnymi wartoœciami
        let totalSeconds = state.timeToClean;
        cleanTimeHourInput.value = Math.floor(totalSeconds / 3600);
        cleanTimeMinuteInput.value = Math.floor((totalSeconds % 3600) / 60);
        cleanTimeSecondInput.value = totalSeconds % 60;
    });

    updateCleanBtn.addEventListener('click', () => {
        const hours = parseInt(cleanTimeHourInput.value) || 0;
        const minutes = parseInt(cleanTimeMinuteInput.value) || 0;
        const seconds = parseInt(cleanTimeSecondInput.value) || 0;
        const newTotalSeconds = (hours * 3600) + (minutes * 60) + seconds;

        publishControl({
            timeToClean: newTotalSeconds
        });
        editCleanContainer.style.display = 'none'; // Ukryj po aktualizacji
    });


    // Tabs functionality
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.style.display = 'none');

            tab.classList.add('active');
            const target = tab.dataset.target;
            document.getElementById(target).style.display = 'block';
        });
    });

    // Ustaw domyœln¹ aktywn¹ zak³adkê
    document.querySelector('.tab.active').click();


    // Inicjalizacja
    initCharts();
    connectMqtt();
});